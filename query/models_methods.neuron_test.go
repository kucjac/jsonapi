// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Tue, 19 May 2020 10:03:31 +0200

package query

import (
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"time"
)

// Compile time check if RelatedModel implements mapping.Model interface.
var _ mapping.Model = &RelatedModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'RelatedModel'.
func (r *RelatedModel) NeuronCollectionName() string {
	return "related_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (r *RelatedModel) IsPrimaryKeyZero() bool {
	return r.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (r *RelatedModel) GetPrimaryKeyValue() interface{} {
	return r.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (r *RelatedModel) GetPrimaryKeyAddress() interface{} {
	return &r.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (r *RelatedModel) GetPrimaryKeyHashableValue() interface{} {
	return r.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (r *RelatedModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (r *RelatedModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		r.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		r.ID = int(valueType)
	case int16:
		r.ID = int(valueType)
	case int32:
		r.ID = int(valueType)
	case int64:
		r.ID = int(valueType)
	case uint:
		r.ID = int(valueType)
	case uint8:
		r.ID = int(valueType)
	case uint16:
		r.ID = int(valueType)
	case uint32:
		r.ID = int(valueType)
	case uint64:
		r.ID = int(valueType)
	case float32:
		r.ID = int(valueType)
	case float64:
		r.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'RelatedModel'", value)
	}
	return nil
}

// Compile time check if RelatedModel implements mapping.Fielder interface.
var _ mapping.Fielder = &RelatedModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (r *RelatedModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &r.ID, nil
	case 1: // FloatField
		return &r.FloatField, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: RelatedModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (r *RelatedModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // FloatField
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (r *RelatedModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID == 0, nil
	case 1: // FloatField
		return r.FloatField == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (r *RelatedModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		r.ID = 0
	case 1: // FloatField
		r.FloatField = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (r *RelatedModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID, nil
	case 1: // FloatField
		return r.FloatField, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'RelatedModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (r *RelatedModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID, nil
	case 1: // FloatField
		return r.FloatField, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: RelatedModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (r *RelatedModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			r.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			r.ID = int(v)
		case int16:
			r.ID = int(v)
		case int32:
			r.ID = int(v)
		case int64:
			r.ID = int(v)
		case uint:
			r.ID = int(v)
		case uint8:
			r.ID = int(v)
		case uint16:
			r.ID = int(v)
		case uint32:
			r.ID = int(v)
		case uint64:
			r.ID = int(v)
		case float32:
			r.ID = int(v)
		case float64:
			r.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // FloatField
		if v, ok := value.(float64); ok {
			r.FloatField = v
			return nil
		}
		switch v := value.(type) {
		case int:
			r.FloatField = float64(v)
		case int8:
			r.FloatField = float64(v)
		case int16:
			r.FloatField = float64(v)
		case int32:
			r.FloatField = float64(v)
		case int64:
			r.FloatField = float64(v)
		case uint:
			r.FloatField = float64(v)
		case uint8:
			r.FloatField = float64(v)
		case uint16:
			r.FloatField = float64(v)
		case uint32:
			r.FloatField = float64(v)
		case uint64:
			r.FloatField = float64(v)
		case float32:
			r.FloatField = float64(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'RelatedModel'", field.Name())
	}
}

// Compile time check if FormatterRelation implements mapping.Model interface.
var _ mapping.Model = &FormatterRelation{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'FormatterRelation'.
func (f *FormatterRelation) NeuronCollectionName() string {
	return "formatter_relations"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (f *FormatterRelation) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (f *FormatterRelation) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (f *FormatterRelation) GetPrimaryKeyAddress() interface{} {
	return &f.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (f *FormatterRelation) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (f *FormatterRelation) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (f *FormatterRelation) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'FormatterRelation'", value)
	}
	return nil
}

// Compile time check if FormatterRelation implements mapping.Fielder interface.
var _ mapping.Fielder = &FormatterRelation{}

// GetFieldsAddress gets the address of provided 'field'.
func (f *FormatterRelation) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &f.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: FormatterRelation'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (f *FormatterRelation) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (f *FormatterRelation) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (f *FormatterRelation) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		f.ID = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (f *FormatterRelation) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'FormatterRelation'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (f *FormatterRelation) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: FormatterRelation'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (f *FormatterRelation) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			f.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.ID = int(v)
		case int16:
			f.ID = int(v)
		case int32:
			f.ID = int(v)
		case int64:
			f.ID = int(v)
		case uint:
			f.ID = int(v)
		case uint8:
			f.ID = int(v)
		case uint16:
			f.ID = int(v)
		case uint32:
			f.ID = int(v)
		case uint64:
			f.ID = int(v)
		case float32:
			f.ID = int(v)
		case float64:
			f.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'FormatterRelation'", field.Name())
	}
}

// Compile time check if FilterRelationModel implements mapping.Model interface.
var _ mapping.Model = &FilterRelationModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'FilterRelationModel'.
func (f *FilterRelationModel) NeuronCollectionName() string {
	return "filter_relation_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (f *FilterRelationModel) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (f *FilterRelationModel) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (f *FilterRelationModel) GetPrimaryKeyAddress() interface{} {
	return &f.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (f *FilterRelationModel) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (f *FilterRelationModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (f *FilterRelationModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'FilterRelationModel'", value)
	}
	return nil
}

// Compile time check if FilterRelationModel implements mapping.Fielder interface.
var _ mapping.Fielder = &FilterRelationModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (f *FilterRelationModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &f.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: FilterRelationModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (f *FilterRelationModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (f *FilterRelationModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (f *FilterRelationModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		f.ID = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (f *FilterRelationModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'FilterRelationModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (f *FilterRelationModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: FilterRelationModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (f *FilterRelationModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			f.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.ID = int(v)
		case int16:
			f.ID = int(v)
		case int32:
			f.ID = int(v)
		case int64:
			f.ID = int(v)
		case uint:
			f.ID = int(v)
		case uint8:
			f.ID = int(v)
		case uint16:
			f.ID = int(v)
		case uint32:
			f.ID = int(v)
		case uint64:
			f.ID = int(v)
		case float32:
			f.ID = int(v)
		case float64:
			f.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'FilterRelationModel'", field.Name())
	}
}

// Compile time check if HasManyModel implements mapping.Model interface.
var _ mapping.Model = &HasManyModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'HasManyModel'.
func (h *HasManyModel) NeuronCollectionName() string {
	return "has_many_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (h *HasManyModel) IsPrimaryKeyZero() bool {
	return h.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (h *HasManyModel) GetPrimaryKeyValue() interface{} {
	return h.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (h *HasManyModel) GetPrimaryKeyAddress() interface{} {
	return &h.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (h *HasManyModel) GetPrimaryKeyHashableValue() interface{} {
	return h.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (h *HasManyModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (h *HasManyModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		h.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		h.ID = int(valueType)
	case int16:
		h.ID = int(valueType)
	case int32:
		h.ID = int(valueType)
	case int64:
		h.ID = int(valueType)
	case uint:
		h.ID = int(valueType)
	case uint8:
		h.ID = int(valueType)
	case uint16:
		h.ID = int(valueType)
	case uint32:
		h.ID = int(valueType)
	case uint64:
		h.ID = int(valueType)
	case float32:
		h.ID = int(valueType)
	case float64:
		h.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'HasManyModel'", value)
	}
	return nil
}

// Compile time check if HasManyModel implements mapping.Fielder interface.
var _ mapping.Fielder = &HasManyModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (h *HasManyModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HasManyModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (h *HasManyModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (h *HasManyModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (h *HasManyModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		h.ID = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (h *HasManyModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'HasManyModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (h *HasManyModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HasManyModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (h *HasManyModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			h.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			h.ID = int(v)
		case int16:
			h.ID = int(v)
		case int32:
			h.ID = int(v)
		case int64:
			h.ID = int(v)
		case uint:
			h.ID = int(v)
		case uint8:
			h.ID = int(v)
		case uint16:
			h.ID = int(v)
		case uint32:
			h.ID = int(v)
		case uint64:
			h.ID = int(v)
		case float32:
			h.ID = int(v)
		case float64:
			h.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'HasManyModel'", field.Name())
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &HasManyModel{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (h *HasManyModel) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 1: // HasMany
		foreignModel, ok := model.(*ForeignModel)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'HasMany'", model)
		}
		h.HasMany = append(h.HasMany, foreignModel)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'HasManyModel'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (h *HasManyModel) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 1: // HasMany
		for _, model := range h.HasMany {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (h *HasManyModel) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 1: // HasMany
		if index > len(h.HasMany)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'HasManyModel', Field HasMany")
		}
		return h.HasMany[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (h *HasManyModel) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // HasMany
		return len(h.HasMany), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
}

// Compile time check if ForeignModel implements mapping.Model interface.
var _ mapping.Model = &ForeignModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'ForeignModel'.
func (f *ForeignModel) NeuronCollectionName() string {
	return "foreign_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (f *ForeignModel) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (f *ForeignModel) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (f *ForeignModel) GetPrimaryKeyAddress() interface{} {
	return &f.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (f *ForeignModel) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (f *ForeignModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (f *ForeignModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ForeignModel'", value)
	}
	return nil
}

// Compile time check if ForeignModel implements mapping.Fielder interface.
var _ mapping.Fielder = &ForeignModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (f *ForeignModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &f.ID, nil
	case 1: // ForeignKey
		return &f.ForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ForeignModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (f *ForeignModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // ForeignKey
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (f *ForeignModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID == 0, nil
	case 1: // ForeignKey
		return f.ForeignKey == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (f *ForeignModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		f.ID = 0
	case 1: // ForeignKey
		f.ForeignKey = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (f *ForeignModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 1: // ForeignKey
		return f.ForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ForeignModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (f *ForeignModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 1: // ForeignKey
		return f.ForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ForeignModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (f *ForeignModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			f.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.ID = int(v)
		case int16:
			f.ID = int(v)
		case int32:
			f.ID = int(v)
		case int64:
			f.ID = int(v)
		case uint:
			f.ID = int(v)
		case uint8:
			f.ID = int(v)
		case uint16:
			f.ID = int(v)
		case uint32:
			f.ID = int(v)
		case uint64:
			f.ID = int(v)
		case float32:
			f.ID = int(v)
		case float64:
			f.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // ForeignKey
		if v, ok := value.(int); ok {
			f.ForeignKey = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.ForeignKey = int(v)
		case int16:
			f.ForeignKey = int(v)
		case int32:
			f.ForeignKey = int(v)
		case int64:
			f.ForeignKey = int(v)
		case uint:
			f.ForeignKey = int(v)
		case uint8:
			f.ForeignKey = int(v)
		case uint16:
			f.ForeignKey = int(v)
		case uint32:
			f.ForeignKey = int(v)
		case uint64:
			f.ForeignKey = int(v)
		case float32:
			f.ForeignKey = int(v)
		case float64:
			f.ForeignKey = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ForeignModel'", field.Name())
	}
}

// Compile time check if ManyToManyModel implements mapping.Model interface.
var _ mapping.Model = &ManyToManyModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'ManyToManyModel'.
func (m *ManyToManyModel) NeuronCollectionName() string {
	return "many_to_many_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *ManyToManyModel) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *ManyToManyModel) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (m *ManyToManyModel) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *ManyToManyModel) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *ManyToManyModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *ManyToManyModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ManyToManyModel'", value)
	}
	return nil
}

// Compile time check if ManyToManyModel implements mapping.Fielder interface.
var _ mapping.Fielder = &ManyToManyModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ManyToManyModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ManyToManyModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (m *ManyToManyModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (m *ManyToManyModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (m *ManyToManyModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (m *ManyToManyModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ManyToManyModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (m *ManyToManyModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ManyToManyModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (m *ManyToManyModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ManyToManyModel'", field.Name())
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &ManyToManyModel{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (m *ManyToManyModel) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 1: // Many2Many
		relatedModel, ok := model.(*RelatedModel)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Many2Many'", model)
		}
		m.Many2Many = append(m.Many2Many, relatedModel)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'ManyToManyModel'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (m *ManyToManyModel) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 1: // Many2Many
		for _, model := range m.Many2Many {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (m *ManyToManyModel) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 1: // Many2Many
		if index > len(m.Many2Many)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'ManyToManyModel', Field Many2Many")
		}
		return m.Many2Many[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (m *ManyToManyModel) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Many2Many
		return len(m.Many2Many), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if Formatter implements mapping.Model interface.
var _ mapping.Model = &Formatter{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Formatter'.
func (f *Formatter) NeuronCollectionName() string {
	return "formatters"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (f *Formatter) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (f *Formatter) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (f *Formatter) GetPrimaryKeyAddress() interface{} {
	return &f.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (f *Formatter) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (f *Formatter) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (f *Formatter) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Formatter'", value)
	}
	return nil
}

// Compile time check if Formatter implements mapping.Fielder interface.
var _ mapping.Fielder = &Formatter{}

// GetFieldsAddress gets the address of provided 'field'.
func (f *Formatter) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &f.ID, nil
	case 1: // Attr
		return &f.Attr, nil
	case 3: // FK
		return &f.FK, nil
	case 4: // Lang
		return &f.Lang, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Formatter'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (f *Formatter) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Attr
		return "", nil
	case 3: // FK
		return 0, nil
	case 4: // Lang
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (f *Formatter) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID == 0, nil
	case 1: // Attr
		return f.Attr == "", nil
	case 3: // FK
		return f.FK == 0, nil
	case 4: // Lang
		return f.Lang == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (f *Formatter) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		f.ID = 0
	case 1: // Attr
		f.Attr = ""
	case 3: // FK
		f.FK = 0
	case 4: // Lang
		f.Lang = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (f *Formatter) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 1: // Attr
		return f.Attr, nil
	case 3: // FK
		return f.FK, nil
	case 4: // Lang
		return f.Lang, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Formatter'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (f *Formatter) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 1: // Attr
		return f.Attr, nil
	case 3: // FK
		return f.FK, nil
	case 4: // Lang
		return f.Lang, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Formatter'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (f *Formatter) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			f.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.ID = int(v)
		case int16:
			f.ID = int(v)
		case int32:
			f.ID = int(v)
		case int64:
			f.ID = int(v)
		case uint:
			f.ID = int(v)
		case uint8:
			f.ID = int(v)
		case uint16:
			f.ID = int(v)
		case uint32:
			f.ID = int(v)
		case uint64:
			f.ID = int(v)
		case float32:
			f.ID = int(v)
		case float64:
			f.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Attr
		if v, ok := value.(string); ok {
			f.Attr = v
			return nil
		}
		// Check alternate types for the Attr.
		if v, ok := value.([]byte); ok {
			f.Attr = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // FK
		if v, ok := value.(int); ok {
			f.FK = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.FK = int(v)
		case int16:
			f.FK = int(v)
		case int32:
			f.FK = int(v)
		case int64:
			f.FK = int(v)
		case uint:
			f.FK = int(v)
		case uint8:
			f.FK = int(v)
		case uint16:
			f.FK = int(v)
		case uint32:
			f.FK = int(v)
		case uint64:
			f.FK = int(v)
		case float32:
			f.FK = int(v)
		case float64:
			f.FK = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // Lang
		if v, ok := value.(string); ok {
			f.Lang = v
			return nil
		}
		// Check alternate types for the Lang.
		if v, ok := value.([]byte); ok {
			f.Lang = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Formatter'", field.Name())
	}
}

// Compile time check if Formatter implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Formatter{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (f *Formatter) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 2: // Rel
		return f.Rel, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (f *Formatter) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Rel
		if model == nil {
			f.Rel = nil
			return nil
		} else if rel, ok := model.(*FormatterRelation); ok {
			f.Rel = rel
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Rel", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
}

// Compile time check if HasOneModel implements mapping.Model interface.
var _ mapping.Model = &HasOneModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'HasOneModel'.
func (h *HasOneModel) NeuronCollectionName() string {
	return "has_one_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (h *HasOneModel) IsPrimaryKeyZero() bool {
	return h.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (h *HasOneModel) GetPrimaryKeyValue() interface{} {
	return h.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (h *HasOneModel) GetPrimaryKeyAddress() interface{} {
	return &h.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (h *HasOneModel) GetPrimaryKeyHashableValue() interface{} {
	return h.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (h *HasOneModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (h *HasOneModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		h.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		h.ID = int(valueType)
	case int16:
		h.ID = int(valueType)
	case int32:
		h.ID = int(valueType)
	case int64:
		h.ID = int(valueType)
	case uint:
		h.ID = int(valueType)
	case uint8:
		h.ID = int(valueType)
	case uint16:
		h.ID = int(valueType)
	case uint32:
		h.ID = int(valueType)
	case uint64:
		h.ID = int(valueType)
	case float32:
		h.ID = int(valueType)
	case float64:
		h.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'HasOneModel'", value)
	}
	return nil
}

// Compile time check if HasOneModel implements mapping.Fielder interface.
var _ mapping.Fielder = &HasOneModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (h *HasOneModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HasOneModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (h *HasOneModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (h *HasOneModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (h *HasOneModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		h.ID = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (h *HasOneModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'HasOneModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (h *HasOneModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HasOneModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (h *HasOneModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			h.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			h.ID = int(v)
		case int16:
			h.ID = int(v)
		case int32:
			h.ID = int(v)
		case int64:
			h.ID = int(v)
		case uint:
			h.ID = int(v)
		case uint8:
			h.ID = int(v)
		case uint16:
			h.ID = int(v)
		case uint32:
			h.ID = int(v)
		case uint64:
			h.ID = int(v)
		case float32:
			h.ID = int(v)
		case float64:
			h.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'HasOneModel'", field.Name())
	}
}

// Compile time check if HasOneModel implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &HasOneModel{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (h *HasOneModel) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 1: // HasOne
		return h.HasOne, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (h *HasOneModel) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 1: // HasOne
		if model == nil {
			h.HasOne = nil
			return nil
		} else if hasOne, ok := model.(*ForeignModel); ok {
			h.HasOne = hasOne
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation HasOne", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
}

// Compile time check if HasManyWithRelation implements mapping.Model interface.
var _ mapping.Model = &HasManyWithRelation{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'HasManyWithRelation'.
func (h *HasManyWithRelation) NeuronCollectionName() string {
	return "has_many_with_relations"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (h *HasManyWithRelation) IsPrimaryKeyZero() bool {
	return h.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (h *HasManyWithRelation) GetPrimaryKeyValue() interface{} {
	return h.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (h *HasManyWithRelation) GetPrimaryKeyAddress() interface{} {
	return &h.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (h *HasManyWithRelation) GetPrimaryKeyHashableValue() interface{} {
	return h.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (h *HasManyWithRelation) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (h *HasManyWithRelation) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		h.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		h.ID = int(valueType)
	case int16:
		h.ID = int(valueType)
	case int32:
		h.ID = int(valueType)
	case int64:
		h.ID = int(valueType)
	case uint:
		h.ID = int(valueType)
	case uint8:
		h.ID = int(valueType)
	case uint16:
		h.ID = int(valueType)
	case uint32:
		h.ID = int(valueType)
	case uint64:
		h.ID = int(valueType)
	case float32:
		h.ID = int(valueType)
	case float64:
		h.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'HasManyWithRelation'", value)
	}
	return nil
}

// Compile time check if HasManyWithRelation implements mapping.Fielder interface.
var _ mapping.Fielder = &HasManyWithRelation{}

// GetFieldsAddress gets the address of provided 'field'.
func (h *HasManyWithRelation) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HasManyWithRelation'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (h *HasManyWithRelation) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (h *HasManyWithRelation) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (h *HasManyWithRelation) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		h.ID = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (h *HasManyWithRelation) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'HasManyWithRelation'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (h *HasManyWithRelation) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HasManyWithRelation'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (h *HasManyWithRelation) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			h.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			h.ID = int(v)
		case int16:
			h.ID = int(v)
		case int32:
			h.ID = int(v)
		case int64:
			h.ID = int(v)
		case uint:
			h.ID = int(v)
		case uint8:
			h.ID = int(v)
		case uint16:
			h.ID = int(v)
		case uint32:
			h.ID = int(v)
		case uint64:
			h.ID = int(v)
		case float32:
			h.ID = int(v)
		case float64:
			h.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'HasManyWithRelation'", field.Name())
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &HasManyWithRelation{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (h *HasManyWithRelation) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 1: // Relation
		foreignWithRelation, ok := model.(*ForeignWithRelation)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Relation'", model)
		}
		h.Relation = append(h.Relation, foreignWithRelation)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'HasManyWithRelation'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (h *HasManyWithRelation) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 1: // Relation
		for _, model := range h.Relation {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (h *HasManyWithRelation) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 1: // Relation
		if index > len(h.Relation)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'HasManyWithRelation', Field Relation")
		}
		return h.Relation[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (h *HasManyWithRelation) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Relation
		return len(h.Relation), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, h)
	}
}

// Compile time check if TestingModel implements mapping.Model interface.
var _ mapping.Model = &TestingModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'TestingModel'.
func (t *TestingModel) NeuronCollectionName() string {
	return "testing_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (t *TestingModel) IsPrimaryKeyZero() bool {
	return t.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (t *TestingModel) GetPrimaryKeyValue() interface{} {
	return t.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (t *TestingModel) GetPrimaryKeyAddress() interface{} {
	return &t.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (t *TestingModel) GetPrimaryKeyHashableValue() interface{} {
	return t.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (t *TestingModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (t *TestingModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		t.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		t.ID = int(valueType)
	case int16:
		t.ID = int(valueType)
	case int32:
		t.ID = int(valueType)
	case int64:
		t.ID = int(valueType)
	case uint:
		t.ID = int(valueType)
	case uint8:
		t.ID = int(valueType)
	case uint16:
		t.ID = int(valueType)
	case uint32:
		t.ID = int(valueType)
	case uint64:
		t.ID = int(valueType)
	case float32:
		t.ID = int(valueType)
	case float64:
		t.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'TestingModel'", value)
	}
	return nil
}

// Compile time check if TestingModel implements mapping.Fielder interface.
var _ mapping.Fielder = &TestingModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (t *TestingModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &t.ID, nil
	case 1: // Attr
		return &t.Attr, nil
	case 3: // ForeignKey
		return &t.ForeignKey, nil
	case 4: // Nested
		return &t.Nested, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: TestingModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (t *TestingModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Attr
		return "", nil
	case 3: // ForeignKey
		return 0, nil
	case 4: // Nested
		return (*FilterNestedModel)(nil), nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (t *TestingModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID == 0, nil
	case 1: // Attr
		return t.Attr == "", nil
	case 3: // ForeignKey
		return t.ForeignKey == 0, nil
	case 4: // Nested
		return t.Nested == nil, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (t *TestingModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		t.ID = 0
	case 1: // Attr
		t.Attr = ""
	case 3: // ForeignKey
		t.ForeignKey = 0
	case 4: // Nested
		t.Nested = nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (t *TestingModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID, nil
	case 1: // Attr
		return t.Attr, nil
	case 3: // ForeignKey
		return t.ForeignKey, nil
	case 4: // Nested
		if t.Nested == nil {
			return t.Nested, nil
		}
		return *t.Nested, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'TestingModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (t *TestingModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID, nil
	case 1: // Attr
		return t.Attr, nil
	case 3: // ForeignKey
		return t.ForeignKey, nil
	case 4: // Nested
		return t.Nested, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: TestingModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (t *TestingModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			t.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			t.ID = int(v)
		case int16:
			t.ID = int(v)
		case int32:
			t.ID = int(v)
		case int64:
			t.ID = int(v)
		case uint:
			t.ID = int(v)
		case uint8:
			t.ID = int(v)
		case uint16:
			t.ID = int(v)
		case uint32:
			t.ID = int(v)
		case uint64:
			t.ID = int(v)
		case float32:
			t.ID = int(v)
		case float64:
			t.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Attr
		if v, ok := value.(string); ok {
			t.Attr = v
			return nil
		}
		// Check alternate types for the Attr.
		if v, ok := value.([]byte); ok {
			t.Attr = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // ForeignKey
		if v, ok := value.(int); ok {
			t.ForeignKey = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			t.ForeignKey = int(v)
		case int16:
			t.ForeignKey = int(v)
		case int32:
			t.ForeignKey = int(v)
		case int64:
			t.ForeignKey = int(v)
		case uint:
			t.ForeignKey = int(v)
		case uint8:
			t.ForeignKey = int(v)
		case uint16:
			t.ForeignKey = int(v)
		case uint32:
			t.ForeignKey = int(v)
		case uint64:
			t.ForeignKey = int(v)
		case float32:
			t.ForeignKey = int(v)
		case float64:
			t.ForeignKey = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // Nested
		if value == nil {
			t.Nested = nil
			return nil
		}
		if v, ok := value.(*FilterNestedModel); ok {
			t.Nested = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(FilterNestedModel); ok {
			t.Nested = &v
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'TestingModel'", field.Name())
	}
}

// Compile time check if TestingModel implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &TestingModel{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (t *TestingModel) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 2: // Relation
		return t.Relation, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, t)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (t *TestingModel) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Relation
		if model == nil {
			t.Relation = nil
			return nil
		} else if relation, ok := model.(*FilterRelationModel); ok {
			t.Relation = relation
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Relation", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, t)
	}
}

// Compile time check if JoinModel implements mapping.Model interface.
var _ mapping.Model = &JoinModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'JoinModel'.
func (j *JoinModel) NeuronCollectionName() string {
	return "join_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (j *JoinModel) IsPrimaryKeyZero() bool {
	return j.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (j *JoinModel) GetPrimaryKeyValue() interface{} {
	return j.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (j *JoinModel) GetPrimaryKeyAddress() interface{} {
	return &j.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (j *JoinModel) GetPrimaryKeyHashableValue() interface{} {
	return j.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (j *JoinModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (j *JoinModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		j.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		j.ID = int(valueType)
	case int16:
		j.ID = int(valueType)
	case int32:
		j.ID = int(valueType)
	case int64:
		j.ID = int(valueType)
	case uint:
		j.ID = int(valueType)
	case uint8:
		j.ID = int(valueType)
	case uint16:
		j.ID = int(valueType)
	case uint32:
		j.ID = int(valueType)
	case uint64:
		j.ID = int(valueType)
	case float32:
		j.ID = int(valueType)
	case float64:
		j.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'JoinModel'", value)
	}
	return nil
}

// Compile time check if JoinModel implements mapping.Fielder interface.
var _ mapping.Fielder = &JoinModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (j *JoinModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &j.ID, nil
	case 1: // ForeignKey
		return &j.ForeignKey, nil
	case 2: // MtMForeignKey
		return &j.MtMForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: JoinModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (j *JoinModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // ForeignKey
		return 0, nil
	case 2: // MtMForeignKey
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (j *JoinModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID == 0, nil
	case 1: // ForeignKey
		return j.ForeignKey == 0, nil
	case 2: // MtMForeignKey
		return j.MtMForeignKey == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (j *JoinModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		j.ID = 0
	case 1: // ForeignKey
		j.ForeignKey = 0
	case 2: // MtMForeignKey
		j.MtMForeignKey = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (j *JoinModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID, nil
	case 1: // ForeignKey
		return j.ForeignKey, nil
	case 2: // MtMForeignKey
		return j.MtMForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'JoinModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (j *JoinModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID, nil
	case 1: // ForeignKey
		return j.ForeignKey, nil
	case 2: // MtMForeignKey
		return j.MtMForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: JoinModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (j *JoinModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			j.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			j.ID = int(v)
		case int16:
			j.ID = int(v)
		case int32:
			j.ID = int(v)
		case int64:
			j.ID = int(v)
		case uint:
			j.ID = int(v)
		case uint8:
			j.ID = int(v)
		case uint16:
			j.ID = int(v)
		case uint32:
			j.ID = int(v)
		case uint64:
			j.ID = int(v)
		case float32:
			j.ID = int(v)
		case float64:
			j.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // ForeignKey
		if v, ok := value.(int); ok {
			j.ForeignKey = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			j.ForeignKey = int(v)
		case int16:
			j.ForeignKey = int(v)
		case int32:
			j.ForeignKey = int(v)
		case int64:
			j.ForeignKey = int(v)
		case uint:
			j.ForeignKey = int(v)
		case uint8:
			j.ForeignKey = int(v)
		case uint16:
			j.ForeignKey = int(v)
		case uint32:
			j.ForeignKey = int(v)
		case uint64:
			j.ForeignKey = int(v)
		case float32:
			j.ForeignKey = int(v)
		case float64:
			j.ForeignKey = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // MtMForeignKey
		if v, ok := value.(int); ok {
			j.MtMForeignKey = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			j.MtMForeignKey = int(v)
		case int16:
			j.MtMForeignKey = int(v)
		case int32:
			j.MtMForeignKey = int(v)
		case int64:
			j.MtMForeignKey = int(v)
		case uint:
			j.MtMForeignKey = int(v)
		case uint8:
			j.MtMForeignKey = int(v)
		case uint16:
			j.MtMForeignKey = int(v)
		case uint32:
			j.MtMForeignKey = int(v)
		case uint64:
			j.MtMForeignKey = int(v)
		case float32:
			j.MtMForeignKey = int(v)
		case float64:
			j.MtMForeignKey = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'JoinModel'", field.Name())
	}
}

// Compile time check if ForeignWithRelation implements mapping.Model interface.
var _ mapping.Model = &ForeignWithRelation{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'ForeignWithRelation'.
func (f *ForeignWithRelation) NeuronCollectionName() string {
	return "foreign_with_relations"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (f *ForeignWithRelation) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (f *ForeignWithRelation) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (f *ForeignWithRelation) GetPrimaryKeyAddress() interface{} {
	return &f.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (f *ForeignWithRelation) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (f *ForeignWithRelation) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (f *ForeignWithRelation) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ForeignWithRelation'", value)
	}
	return nil
}

// Compile time check if ForeignWithRelation implements mapping.Fielder interface.
var _ mapping.Fielder = &ForeignWithRelation{}

// GetFieldsAddress gets the address of provided 'field'.
func (f *ForeignWithRelation) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &f.ID, nil
	case 2: // ForeignKey
		return &f.ForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ForeignWithRelation'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (f *ForeignWithRelation) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 2: // ForeignKey
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (f *ForeignWithRelation) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID == 0, nil
	case 2: // ForeignKey
		return f.ForeignKey == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (f *ForeignWithRelation) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		f.ID = 0
	case 2: // ForeignKey
		f.ForeignKey = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (f *ForeignWithRelation) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 2: // ForeignKey
		return f.ForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ForeignWithRelation'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (f *ForeignWithRelation) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 2: // ForeignKey
		return f.ForeignKey, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ForeignWithRelation'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (f *ForeignWithRelation) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			f.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.ID = int(v)
		case int16:
			f.ID = int(v)
		case int32:
			f.ID = int(v)
		case int64:
			f.ID = int(v)
		case uint:
			f.ID = int(v)
		case uint8:
			f.ID = int(v)
		case uint16:
			f.ID = int(v)
		case uint32:
			f.ID = int(v)
		case uint64:
			f.ID = int(v)
		case float32:
			f.ID = int(v)
		case float64:
			f.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // ForeignKey
		if v, ok := value.(int); ok {
			f.ForeignKey = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.ForeignKey = int(v)
		case int16:
			f.ForeignKey = int(v)
		case int32:
			f.ForeignKey = int(v)
		case int64:
			f.ForeignKey = int(v)
		case uint:
			f.ForeignKey = int(v)
		case uint8:
			f.ForeignKey = int(v)
		case uint16:
			f.ForeignKey = int(v)
		case uint32:
			f.ForeignKey = int(v)
		case uint64:
			f.ForeignKey = int(v)
		case float32:
			f.ForeignKey = int(v)
		case float64:
			f.ForeignKey = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ForeignWithRelation'", field.Name())
	}
}

// Compile time check if ForeignWithRelation implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &ForeignWithRelation{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (f *ForeignWithRelation) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 1: // Relation
		return f.Relation, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (f *ForeignWithRelation) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 1: // Relation
		if model == nil {
			f.Relation = nil
			return nil
		} else if relation, ok := model.(*HasManyWithRelation); ok {
			f.Relation = relation
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Relation", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
}

// Compile time check if Comment implements mapping.Model interface.
var _ mapping.Model = &Comment{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Comment'.
func (c *Comment) NeuronCollectionName() string {
	return "comments"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (c *Comment) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (c *Comment) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (c *Comment) GetPrimaryKeyAddress() interface{} {
	return &c.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (c *Comment) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (c *Comment) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (c *Comment) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Comment'", value)
	}
	return nil
}

// Compile time check if Comment implements mapping.Fielder interface.
var _ mapping.Fielder = &Comment{}

// GetFieldsAddress gets the address of provided 'field'.
func (c *Comment) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &c.ID, nil
	case 1: // PostID
		return &c.PostID, nil
	case 2: // Body
		return &c.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (c *Comment) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // PostID
		return 0, nil
	case 2: // Body
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (c *Comment) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID == 0, nil
	case 1: // PostID
		return c.PostID == 0, nil
	case 2: // Body
		return c.Body == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (c *Comment) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		c.ID = 0
	case 1: // PostID
		c.PostID = 0
	case 2: // Body
		c.Body = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (c *Comment) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // PostID
		return c.PostID, nil
	case 2: // Body
		return c.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Comment'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (c *Comment) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // PostID
		return c.PostID, nil
	case 2: // Body
		return c.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (c *Comment) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			c.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			c.ID = int(v)
		case int16:
			c.ID = int(v)
		case int32:
			c.ID = int(v)
		case int64:
			c.ID = int(v)
		case uint:
			c.ID = int(v)
		case uint8:
			c.ID = int(v)
		case uint16:
			c.ID = int(v)
		case uint32:
			c.ID = int(v)
		case uint64:
			c.ID = int(v)
		case float32:
			c.ID = int(v)
		case float64:
			c.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // PostID
		if v, ok := value.(uint64); ok {
			c.PostID = v
			return nil
		}
		switch v := value.(type) {
		case int:
			c.PostID = uint64(v)
		case int8:
			c.PostID = uint64(v)
		case int16:
			c.PostID = uint64(v)
		case int32:
			c.PostID = uint64(v)
		case int64:
			c.PostID = uint64(v)
		case uint:
			c.PostID = uint64(v)
		case uint8:
			c.PostID = uint64(v)
		case uint16:
			c.PostID = uint64(v)
		case uint32:
			c.PostID = uint64(v)
		case float32:
			c.PostID = uint64(v)
		case float64:
			c.PostID = uint64(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // Body
		if v, ok := value.(string); ok {
			c.Body = v
			return nil
		}
		// Check alternate types for the Body.
		if v, ok := value.([]byte); ok {
			c.Body = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Comment'", field.Name())
	}
}

// Compile time check if Blog implements mapping.Model interface.
var _ mapping.Model = &Blog{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Blog'.
func (b *Blog) NeuronCollectionName() string {
	return "blogs"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (b *Blog) IsPrimaryKeyZero() bool {
	return b.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (b *Blog) GetPrimaryKeyValue() interface{} {
	return b.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (b *Blog) GetPrimaryKeyAddress() interface{} {
	return &b.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (b *Blog) GetPrimaryKeyHashableValue() interface{} {
	return b.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (b *Blog) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (b *Blog) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		b.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		b.ID = int(valueType)
	case int16:
		b.ID = int(valueType)
	case int32:
		b.ID = int(valueType)
	case int64:
		b.ID = int(valueType)
	case uint:
		b.ID = int(valueType)
	case uint8:
		b.ID = int(valueType)
	case uint16:
		b.ID = int(valueType)
	case uint32:
		b.ID = int(valueType)
	case uint64:
		b.ID = int(valueType)
	case float32:
		b.ID = int(valueType)
	case float64:
		b.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Blog'", value)
	}
	return nil
}

// Compile time check if Blog implements mapping.Fielder interface.
var _ mapping.Fielder = &Blog{}

// GetFieldsAddress gets the address of provided 'field'.
func (b *Blog) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &b.ID, nil
	case 1: // Title
		return &b.Title, nil
	case 4: // CurrentPostID
		return &b.CurrentPostID, nil
	case 5: // CreatedAt
		return &b.CreatedAt, nil
	case 6: // ViewCount
		return &b.ViewCount, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (b *Blog) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Title
		return "", nil
	case 4: // CurrentPostID
		return 0, nil
	case 5: // CreatedAt
		return time.Time{}, nil
	case 6: // ViewCount
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (b *Blog) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID == 0, nil
	case 1: // Title
		return b.Title == "", nil
	case 4: // CurrentPostID
		return b.CurrentPostID == 0, nil
	case 5: // CreatedAt
		return b.CreatedAt == time.Time{}, nil
	case 6: // ViewCount
		return b.ViewCount == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (b *Blog) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		b.ID = 0
	case 1: // Title
		b.Title = ""
	case 4: // CurrentPostID
		b.CurrentPostID = 0
	case 5: // CreatedAt
		b.CreatedAt = time.Time{}
	case 6: // ViewCount
		b.ViewCount = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (b *Blog) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // Title
		return b.Title, nil
	case 4: // CurrentPostID
		return b.CurrentPostID, nil
	case 5: // CreatedAt
		return b.CreatedAt, nil
	case 6: // ViewCount
		return b.ViewCount, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Blog'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (b *Blog) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // Title
		return b.Title, nil
	case 4: // CurrentPostID
		return b.CurrentPostID, nil
	case 5: // CreatedAt
		return b.CreatedAt, nil
	case 6: // ViewCount
		return b.ViewCount, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (b *Blog) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			b.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			b.ID = int(v)
		case int16:
			b.ID = int(v)
		case int32:
			b.ID = int(v)
		case int64:
			b.ID = int(v)
		case uint:
			b.ID = int(v)
		case uint8:
			b.ID = int(v)
		case uint16:
			b.ID = int(v)
		case uint32:
			b.ID = int(v)
		case uint64:
			b.ID = int(v)
		case float32:
			b.ID = int(v)
		case float64:
			b.ID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Title
		if v, ok := value.(string); ok {
			b.Title = v
			return nil
		}
		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			b.Title = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // CurrentPostID
		if v, ok := value.(uint64); ok {
			b.CurrentPostID = v
			return nil
		}
		switch v := value.(type) {
		case int:
			b.CurrentPostID = uint64(v)
		case int8:
			b.CurrentPostID = uint64(v)
		case int16:
			b.CurrentPostID = uint64(v)
		case int32:
			b.CurrentPostID = uint64(v)
		case int64:
			b.CurrentPostID = uint64(v)
		case uint:
			b.CurrentPostID = uint64(v)
		case uint8:
			b.CurrentPostID = uint64(v)
		case uint16:
			b.CurrentPostID = uint64(v)
		case uint32:
			b.CurrentPostID = uint64(v)
		case float32:
			b.CurrentPostID = uint64(v)
		case float64:
			b.CurrentPostID = uint64(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 5: // CreatedAt
		if v, ok := value.(time.Time); ok {
			b.CreatedAt = v
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // ViewCount
		if v, ok := value.(int); ok {
			b.ViewCount = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			b.ViewCount = int(v)
		case int16:
			b.ViewCount = int(v)
		case int32:
			b.ViewCount = int(v)
		case int64:
			b.ViewCount = int(v)
		case uint:
			b.ViewCount = int(v)
		case uint8:
			b.ViewCount = int(v)
		case uint16:
			b.ViewCount = int(v)
		case uint32:
			b.ViewCount = int(v)
		case uint64:
			b.ViewCount = int(v)
		case float32:
			b.ViewCount = int(v)
		case float64:
			b.ViewCount = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Blog'", field.Name())
	}
}

// Compile time check if Blog implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Blog{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (b *Blog) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 3: // CurrentPost
		return b.CurrentPost, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (b *Blog) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 3: // CurrentPost
		if model == nil {
			b.CurrentPost = nil
			return nil
		} else if currentPost, ok := model.(*Post); ok {
			b.CurrentPost = currentPost
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation CurrentPost", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Blog{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (b *Blog) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Posts
		post, ok := model.(*Post)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Posts'", model)
		}
		b.Posts = append(b.Posts, post)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Blog'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 2: // Posts
		for _, model := range b.Posts {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 2: // Posts
		if index > len(b.Posts)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'Blog', Field Posts")
		}
		return b.Posts[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 2: // Posts
		return len(b.Posts), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// Compile time check if Post implements mapping.Model interface.
var _ mapping.Model = &Post{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Post'.
func (p *Post) NeuronCollectionName() string {
	return "posts"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (p *Post) IsPrimaryKeyZero() bool {
	return p.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (p *Post) GetPrimaryKeyValue() interface{} {
	return p.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (p *Post) GetPrimaryKeyAddress() interface{} {
	return &p.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (p *Post) GetPrimaryKeyHashableValue() interface{} {
	return p.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (p *Post) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (p *Post) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uint64); ok {
		p.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int:
		p.ID = uint64(valueType)
	case int8:
		p.ID = uint64(valueType)
	case int16:
		p.ID = uint64(valueType)
	case int32:
		p.ID = uint64(valueType)
	case int64:
		p.ID = uint64(valueType)
	case uint:
		p.ID = uint64(valueType)
	case uint8:
		p.ID = uint64(valueType)
	case uint16:
		p.ID = uint64(valueType)
	case uint32:
		p.ID = uint64(valueType)
	case float32:
		p.ID = uint64(valueType)
	case float64:
		p.ID = uint64(valueType)
	default:
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Post'", value)
	}
	return nil
}

// Compile time check if Post implements mapping.Fielder interface.
var _ mapping.Fielder = &Post{}

// GetFieldsAddress gets the address of provided 'field'.
func (p *Post) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &p.ID, nil
	case 1: // BlogID
		return &p.BlogID, nil
	case 2: // Title
		return &p.Title, nil
	case 3: // Body
		return &p.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (p *Post) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // BlogID
		return 0, nil
	case 2: // Title
		return "", nil
	case 3: // Body
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (p *Post) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID == 0, nil
	case 1: // BlogID
		return p.BlogID == 0, nil
	case 2: // Title
		return p.Title == "", nil
	case 3: // Body
		return p.Body == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (p *Post) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		p.ID = 0
	case 1: // BlogID
		p.BlogID = 0
	case 2: // Title
		p.Title = ""
	case 3: // Body
		p.Body = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (p *Post) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // BlogID
		return p.BlogID, nil
	case 2: // Title
		return p.Title, nil
	case 3: // Body
		return p.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Post'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (p *Post) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // BlogID
		return p.BlogID, nil
	case 2: // Title
		return p.Title, nil
	case 3: // Body
		return p.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (p *Post) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uint64); ok {
			p.ID = v
			return nil
		}
		switch v := value.(type) {
		case int:
			p.ID = uint64(v)
		case int8:
			p.ID = uint64(v)
		case int16:
			p.ID = uint64(v)
		case int32:
			p.ID = uint64(v)
		case int64:
			p.ID = uint64(v)
		case uint:
			p.ID = uint64(v)
		case uint8:
			p.ID = uint64(v)
		case uint16:
			p.ID = uint64(v)
		case uint32:
			p.ID = uint64(v)
		case float32:
			p.ID = uint64(v)
		case float64:
			p.ID = uint64(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // BlogID
		if v, ok := value.(int); ok {
			p.BlogID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			p.BlogID = int(v)
		case int16:
			p.BlogID = int(v)
		case int32:
			p.BlogID = int(v)
		case int64:
			p.BlogID = int(v)
		case uint:
			p.BlogID = int(v)
		case uint8:
			p.BlogID = int(v)
		case uint16:
			p.BlogID = int(v)
		case uint32:
			p.BlogID = int(v)
		case uint64:
			p.BlogID = int(v)
		case float32:
			p.BlogID = int(v)
		case float64:
			p.BlogID = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // Title
		if v, ok := value.(string); ok {
			p.Title = v
			return nil
		}
		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			p.Title = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Body
		if v, ok := value.(string); ok {
			p.Body = v
			return nil
		}
		// Check alternate types for the Body.
		if v, ok := value.([]byte); ok {
			p.Body = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Post'", field.Name())
	}
}

// Compile time check if Post implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Post{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (p *Post) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 5: // LatestComment
		return p.LatestComment, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (p *Post) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 5: // LatestComment
		if model == nil {
			p.LatestComment = nil
			return nil
		} else if latestComment, ok := model.(*Comment); ok {
			p.LatestComment = latestComment
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation LatestComment", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Post{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (p *Post) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 4: // Comments
		comment, ok := model.(*Comment)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Comments'", model)
		}
		p.Comments = append(p.Comments, comment)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Post'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (p *Post) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 4: // Comments
		for _, model := range p.Comments {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (p *Post) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 4: // Comments
		if index > len(p.Comments)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'Post', Field Comments")
		}
		return p.Comments[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (p *Post) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 4: // Comments
		return len(p.Comments), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}
