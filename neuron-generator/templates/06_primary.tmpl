{{define "primary" -}}
{{- $out := . -}}
// Compile time check if {{.Name}} implements mapping.Model interface.
var _ mapping.Model = &{{.Name}}{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the '{{.Name}}'.
func ({{.Receiver}} *{{.Name}}) NeuronCollectionName() string {
    return "{{.CollectionName}}"
}

// IsPrimaryKeyZero implements query.Model interface method.
func ({{.Receiver}} *{{.Name}}) IsPrimaryKeyZero() bool {
    return {{.Primary.IsZero}}
}

// GetPrimaryKeyValue implements query.Model interface method.
func ({{.Receiver}} *{{.Name}}) GetPrimaryKeyValue() interface{} {
    return {{.Receiver}}.{{.Primary.Name}}
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func ({{.Receiver}} *{{.Name}}) GetPrimaryKeyHashableValue() interface{} {
    {{if .Primary.IsPointer -}}
    if {{.Receiver}}.{{.Primary.Name}} == nil {
        return {{.Receiver}}.{{.Primary.Name}}
    }
    {{end -}}
    {{if .Primary.IsByteSlice -}}
    return string({{if .Primary.IsPointer}}*{{end}}{{.Receiver}}.{{.Primary.Name}})
    {{else -}}
    return {{if .Primary.IsPointer}}*{{end}}{{.Receiver}}.{{.Primary.Name}}
    {{end -}}
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func ({{.Receiver}} *{{.Name}}) GetPrimaryKeyZeroValue() interface{} {
    return {{if eq .Primary.Zero "nil"}}{{if .Primary.IsPointer}}({{end}}{{.Primary.Type}}{{if .Primary.IsPointer}}){{end}}({{end}}{{.Primary.GetZero}}{{if eq .Primary.Zero "nil"}}){{end}}
}

// SetPrimaryKey implements query.Model interface method.
func ({{.Receiver}} *{{.Name}}) SetPrimaryKeyValue(value interface{}) error {
    {{if .Primary.IsPointer -}}
    if value == nil {
        {{.Receiver}}.{{.Primary.Name}} = nil
        return nil
    }
    {{end -}}
    if v, ok := value.({{.Primary.Type}}); ok {
        {{.Receiver}}.{{.Primary.Name}} = v
        return nil
    {{if and (not .Primary.IsSlice) .Primary.IsPointer -}}
    } else if v, ok := value.({{.Primary.BaseType}}); ok {
        {{.Receiver}}.{{.Primary.Name}} = &v
        return nil
    {{end -}}{{range $wrapped := .Primary.WrappedTypes -}}
    } else if v, ok := value.({{$wrapped}}); ok {
        {{if .Primary.IsPointer -}}
        temp := {{slice .Primary.Type 1}}(v)
        {{$out.Receiver}}.{{.Primary.Name}} = &temp
        {{else -}}
        {{$out.Receiver}}.{{.Primary.Name}} = {{.Primary.BaseType}}(v)
        {{end -}}
    {{end -}}
    }
    {{if le (len .Primary.AlternateTypes) 1 -}}
    {{- if eq (len .Primary.AlternateTypes) 1 -}}
    // Check alternate types for given field.
    if v, ok := value.({{index .Primary.AlternateTypes 0}}); ok {
        {{if $out.Primary.IsPointer -}}
        temp := {{slice $out.Primary.Type 1}}(v)
        {{$out.Receiver}}.{{$out.Primary.Name}} = &temp
        {{- else -}}
        {{$out.Receiver}}.{{$out.Primary.Name}} = {{$out.Primary.Type}}(v)
        {{- end}}
        return nil
    }
    {{end -}}{{if .Primary.Scanner -}}
        return {{.Receiver}}.{{.Primary.Name}}.Scan(value)
    {{else -}}
        return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
        value, {{.Receiver}}){{end}}
    {{- else -}}
    // Check alternate types for given field.
    switch valueType := value.(type) {
    {{range $alternate := .Primary.AlternateTypes -}}
    case {{$alternate}}:
        {{if $out.Primary.IsPointer -}}
        temp := {{$out.Primary.BaseType}}(valueType)
        {{$out.Receiver}}.{{$out.Primary.Name}} = &temp
        {{- else -}}
        {{$out.Receiver}}.{{$out.Primary.Name}} = {{$out.Primary.Type}}(valueType)
        {{- end}}
    {{end -}}default:
        return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '{{.Name}}'", value)
    }
    return nil{{end}}
}{{end}}