// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Wed, 13 May 2020 22:38:59 +0200

package tests

import (
	"time"

	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/neuron-generator/internal/tests/external"
)

// Compile time check if User implements mapping.Model interface.
var _ mapping.Model = &User{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'User'.
func (u *User) NeuronCollectionName() string {
	return "users"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (u *User) IsPrimaryKeyZero() bool {
	return u.ID == [16]byte{}
}

// GetPrimaryKeyValue implements query.Model interface method.
func (u *User) GetPrimaryKeyValue() interface{} {
	return u.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (u *User) GetPrimaryKeyHashableValue() interface{} {
	return u.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (u *User) GetPrimaryKeyZeroValue() interface{} {
	return [16]byte{}
}

// SetPrimaryKey implements query.Model interface method.
func (u *User) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.([16]byte); ok {
		u.ID = v
		return nil
	}
	return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, u)
}

// Compile time check if User implements mapping.Fielder interface.
var _ mapping.Fielder = &User{}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (u *User) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // DeletedAt
		return (*time.Time)(nil), nil
	case 3: // Name
		return (*string)(nil), nil
	case 4: // Age
		return 0, nil
	case 5: // Bytes
		return []byte(nil), nil
	case 6: // PtrBytes
		return (*[]byte)(nil), nil
	case 7: // Wrapped
		return external.Int(0), nil
	case 8: // PtrWrapped
		return (*external.Int)(nil), nil
	case 9: // External
		return (*external.Model)(nil), nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (u *User) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return u.CreatedAt == time.Time{}, nil
	case 2: // DeletedAt
		return u.DeletedAt == nil, nil
	case 3: // Name
		return u.Name == nil, nil
	case 4: // Age
		return u.Age == 0, nil
	case 5: // Bytes
		return len(u.Bytes) == 0, nil
	case 6: // PtrBytes
		return u.PtrBytes == nil, nil
	case 7: // Wrapped
		return u.Wrapped == external.Int(0), nil
	case 8: // PtrWrapped
		return u.PtrWrapped == nil, nil
	case 9: // External
		return u.External == nil, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (u *User) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 1: // CreatedAt
		u.CreatedAt = time.Time{}
	case 2: // DeletedAt
		u.DeletedAt = nil
	case 3: // Name
		u.Name = nil
	case 4: // Age
		u.Age = 0
	case 5: // Bytes
		u.Bytes = nil
	case 6: // PtrBytes
		u.PtrBytes = nil
	case 7: // Wrapped
		u.Wrapped = external.Int(0)
	case 8: // PtrWrapped
		u.PtrWrapped = nil
	case 9: // External
		u.External = nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (u *User) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return u.CreatedAt, nil
	case 2: // DeletedAt
		if u.DeletedAt == nil {
			return u.DeletedAt, nil
		}
		return *u.DeletedAt, nil
	case 3: // Name
		if u.Name == nil {
			return u.Name, nil
		}
		return *u.Name, nil
	case 4: // Age
		return u.Age, nil
	case 5: // Bytes
		return string(u.Bytes), nil
	case 6: // PtrBytes
		if u.PtrBytes == nil {
			return u.PtrBytes, nil
		}
		return *u.PtrBytes, nil
	case 7: // Wrapped
		return u.Wrapped, nil
	case 8: // PtrWrapped
		if u.PtrWrapped == nil {
			return u.PtrWrapped, nil
		}
		return *u.PtrWrapped, nil
	case 9: // External
		if u.External == nil {
			return u.External, nil
		}
		return *u.External, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'User'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (u *User) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return u.CreatedAt, nil
	case 2: // DeletedAt
		return u.DeletedAt, nil
	case 3: // Name
		return u.Name, nil
	case 4: // Age
		return u.Age, nil
	case 5: // Bytes
		return u.Bytes, nil
	case 6: // PtrBytes
		return u.PtrBytes, nil
	case 7: // Wrapped
		return u.Wrapped, nil
	case 8: // PtrWrapped
		return u.PtrWrapped, nil
	case 9: // External
		return u.External, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (u *User) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			u.CreatedAt = v
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // DeletedAt
		if value == nil {
			u.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			u.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			u.DeletedAt = &v
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Name
		if value == nil {
			u.Name = nil
			return nil
		}
		if v, ok := value.(*string); ok {
			u.Name = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(string); ok {
			u.Name = &v
			return nil
		}
		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			temp := string(v)
			u.Name = &temp
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // Age
		if v, ok := value.(int); ok {
			u.Age = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			u.Age = int(v)
		case int16:
			u.Age = int(v)
		case int32:
			u.Age = int(v)
		case int64:
			u.Age = int(v)
		case uint:
			u.Age = int(v)
		case uint8:
			u.Age = int(v)
		case uint16:
			u.Age = int(v)
		case uint32:
			u.Age = int(v)
		case uint64:
			u.Age = int(v)
		case float32:
			u.Age = int(v)
		case float64:
			u.Age = int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 5: // Bytes
		if v, ok := value.([]byte); ok {
			u.Bytes = v
			return nil
		}
		// Check alternate types for the Bytes.
		if v, ok := value.(string); ok {
			u.Bytes = []byte(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // PtrBytes
		if value == nil {
			u.PtrBytes = nil
			return nil
		}
		if v, ok := value.(*[]byte); ok {
			u.PtrBytes = v
			return nil
		}
		// Check alternate types for the PtrBytes.
		if v, ok := value.(string); ok {
			temp := []byte(v)
			u.PtrBytes = &temp
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 7: // Wrapped
		if v, ok := value.(external.Int); ok {
			u.Wrapped = v
			return nil
		}
		// Checked wrapped types.
		if v, ok := value.(int); ok {
			u.Wrapped = external.Int(v)
			return nil
		}
		switch v := value.(type) {
		case int8:
			u.Wrapped = external.Int(v)
		case int16:
			u.Wrapped = external.Int(v)
		case int32:
			u.Wrapped = external.Int(v)
		case int64:
			u.Wrapped = external.Int(v)
		case uint:
			u.Wrapped = external.Int(v)
		case uint8:
			u.Wrapped = external.Int(v)
		case uint16:
			u.Wrapped = external.Int(v)
		case uint32:
			u.Wrapped = external.Int(v)
		case uint64:
			u.Wrapped = external.Int(v)
		case float32:
			u.Wrapped = external.Int(v)
		case float64:
			u.Wrapped = external.Int(v)
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 8: // PtrWrapped
		if value == nil {
			u.PtrWrapped = nil
			return nil
		}
		if v, ok := value.(*external.Int); ok {
			u.PtrWrapped = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(external.Int); ok {
			u.PtrWrapped = &v
			return nil
		}
		// Checked wrapped types.
		if v, ok := value.(int); ok {
			temp := external.Int(v)
			u.PtrWrapped = &temp
			return nil
		}
		switch v := value.(type) {
		case int8:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *int8:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case int16:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *int16:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case int32:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *int32:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case int64:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *int64:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case uint:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *uint:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case uint8:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *uint8:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case uint16:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *uint16:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case uint32:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *uint32:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case uint64:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *uint64:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case float32:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *float32:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		case float64:
			temp := external.Int(v)
			u.PtrWrapped = &temp
		case *float64:
			temp := external.Int(*v)
			u.PtrWrapped = &temp
		default:
			return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 9: // External
		if value == nil {
			u.External = nil
			return nil
		}
		if v, ok := value.(*external.Model); ok {
			u.External = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(external.Model); ok {
			u.External = &v
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'User'", field.Name())
	}
}

// Compile time check if User implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &User{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (u *User) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 10: // FavoriteCar
		return &u.FavoriteCar, nil
	case 13: // Sister
		return u.Sister, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (u *User) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 10: // FavoriteCar
		if model == nil {
			u.FavoriteCar = Car{}
			return nil
		} else if favoriteCar, ok := model.(*Car); ok {
			u.FavoriteCar = *favoriteCar
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation FavoriteCar", model)
	case 13: // Sister
		if model == nil {
			u.Sister = nil
			return nil
		} else if sister, ok := model.(*User); ok {
			u.Sister = sister
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Sister", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &User{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (u *User) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 11: // Cars
		car, ok := model.(*Car)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Cars'", model)
		}
		u.Cars = append(u.Cars, car)
	case 12: // Sons
		user, ok := model.(*User)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Sons'", model)
		}
		u.Sons = append(u.Sons, *user)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'User'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (u *User) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 11: // Cars
		for _, model := range u.Cars {
			models = append(models, model)
		}
	case 12: // Sons
		for i := range u.Sons {
			models = append(models, &(u.Sons[i]))
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (u *User) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 11: // Cars
		if index > len(u.Cars)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'User', Field Cars")
		}
		return u.Cars[index], nil
	case 12: // Sons
		if index > len(u.Sons)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'User', Field Sons")
		}
		return &u.Sons[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (u *User) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 11: // Cars
		return len(u.Cars), nil
	case 12: // Sons
		return len(u.Sons), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// Compile time check if Car implements mapping.Model interface.
var _ mapping.Model = &Car{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Car'.
func (c *Car) NeuronCollectionName() string {
	return "cars"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (c *Car) IsPrimaryKeyZero() bool {
	return c.ID == nil
}

// GetPrimaryKeyValue implements query.Model interface method.
func (c *Car) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (c *Car) GetPrimaryKeyHashableValue() interface{} {
	if c.ID == nil {
		return c.ID
	}
	return *c.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (c *Car) GetPrimaryKeyZeroValue() interface{} {
	return (*[16]byte)(nil)
}

// SetPrimaryKey implements query.Model interface method.
func (c *Car) SetPrimaryKeyValue(value interface{}) error {
	if value == nil {
		c.ID = nil
		return nil
	}
	if v, ok := value.(*[16]byte); ok {
		c.ID = v
		return nil
	}
	return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, c)
}

// Compile time check if Car implements mapping.Fielder interface.
var _ mapping.Fielder = &Car{}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (c *Car) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Plates
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (c *Car) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // Plates
		return c.Plates == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (c *Car) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 1: // Plates
		c.Plates = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (c *Car) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Plates
		return c.Plates, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Car'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (c *Car) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Plates
		return c.Plates, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Car'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (c *Car) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // Plates
		if v, ok := value.(string); ok {
			c.Plates = v
			return nil
		}
		// Check alternate types for the Plates.
		if v, ok := value.([]byte); ok {
			c.Plates = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Car'", field.Name())
	}
}
