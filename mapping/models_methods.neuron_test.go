// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Wed, 13 May 2020 19:22:51 +0200

package mapping

import (
	"time"

	"github.com/neuronlabs/neuron/errors"
)

// Compile time check if NotTaggedModel implements Model interface.
var _ Model = &NotTaggedModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'NotTaggedModel'.
func (n *NotTaggedModel) NeuronCollectionName() string {
	return "not_tagged_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (n *NotTaggedModel) IsPrimaryKeyZero() bool {
	return n.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyValue() interface{} {
	return n.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyHashableValue() interface{} {
	return n.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (n *NotTaggedModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		n.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		n.ID = int(valueType)
	case int16:
		n.ID = int(valueType)
	case int32:
		n.ID = int(valueType)
	case int64:
		n.ID = int(valueType)
	case uint:
		n.ID = int(valueType)
	case uint8:
		n.ID = int(valueType)
	case uint16:
		n.ID = int(valueType)
	case uint32:
		n.ID = int(valueType)
	case uint64:
		n.ID = int(valueType)
	case float32:
		n.ID = int(valueType)
	case float64:
		n.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'NotTaggedModel'", value)
	}
	return nil
}

// Compile time check if NotTaggedModel implements Fielder interface.
var _ Fielder = &NotTaggedModel{}

// GetFieldZeroValue implements Fielder interface.s
func (n *NotTaggedModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return "", nil
	case 2: // Age
		return 0, nil
	case 3: // Created
		return time.Time{}, nil
	case 4: // OtherNotTaggedModelID
		return 0, nil
	case 6: // ManyRelationID
		return 0, nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (n *NotTaggedModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // Name
		return n.Name == "", nil
	case 2: // Age
		return n.Age == 0, nil
	case 3: // Created
		return n.Created == time.Time{}, nil
	case 4: // OtherNotTaggedModelID
		return n.OtherNotTaggedModelID == 0, nil
	case 6: // ManyRelationID
		return n.ManyRelationID == 0, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (n *NotTaggedModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // Name
		n.Name = ""
	case 2: // Age
		n.Age = 0
	case 3: // Created
		n.Created = time.Time{}
	case 4: // OtherNotTaggedModelID
		n.OtherNotTaggedModelID = 0
	case 6: // ManyRelationID
		n.ManyRelationID = 0
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (n *NotTaggedModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return n.Name, nil
	case 2: // Age
		return n.Age, nil
	case 3: // Created
		return n.Created, nil
	case 4: // OtherNotTaggedModelID
		return n.OtherNotTaggedModelID, nil
	case 6: // ManyRelationID
		return n.ManyRelationID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'NotTaggedModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (n *NotTaggedModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return n.Name, nil
	case 2: // Age
		return n.Age, nil
	case 3: // Created
		return n.Created, nil
	case 4: // OtherNotTaggedModelID
		return n.OtherNotTaggedModelID, nil
	case 6: // ManyRelationID
		return n.ManyRelationID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: NotTaggedModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (n *NotTaggedModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // Name
		if v, ok := value.(string); ok {
			n.Name = v
			return nil
		}
		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			n.Name = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // Age
		if v, ok := value.(int); ok {
			n.Age = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			n.Age = int(v)
		case int16:
			n.Age = int(v)
		case int32:
			n.Age = int(v)
		case int64:
			n.Age = int(v)
		case uint:
			n.Age = int(v)
		case uint8:
			n.Age = int(v)
		case uint16:
			n.Age = int(v)
		case uint32:
			n.Age = int(v)
		case uint64:
			n.Age = int(v)
		case float32:
			n.Age = int(v)
		case float64:
			n.Age = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 3: // Created
		if v, ok := value.(time.Time); ok {
			n.Created = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // OtherNotTaggedModelID
		if v, ok := value.(int); ok {
			n.OtherNotTaggedModelID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			n.OtherNotTaggedModelID = int(v)
		case int16:
			n.OtherNotTaggedModelID = int(v)
		case int32:
			n.OtherNotTaggedModelID = int(v)
		case int64:
			n.OtherNotTaggedModelID = int(v)
		case uint:
			n.OtherNotTaggedModelID = int(v)
		case uint8:
			n.OtherNotTaggedModelID = int(v)
		case uint16:
			n.OtherNotTaggedModelID = int(v)
		case uint32:
			n.OtherNotTaggedModelID = int(v)
		case uint64:
			n.OtherNotTaggedModelID = int(v)
		case float32:
			n.OtherNotTaggedModelID = int(v)
		case float64:
			n.OtherNotTaggedModelID = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 6: // ManyRelationID
		if v, ok := value.(int); ok {
			n.ManyRelationID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			n.ManyRelationID = int(v)
		case int16:
			n.ManyRelationID = int(v)
		case int32:
			n.ManyRelationID = int(v)
		case int64:
			n.ManyRelationID = int(v)
		case uint:
			n.ManyRelationID = int(v)
		case uint8:
			n.ManyRelationID = int(v)
		case uint16:
			n.ManyRelationID = int(v)
		case uint32:
			n.ManyRelationID = int(v)
		case uint64:
			n.ManyRelationID = int(v)
		case float32:
			n.ManyRelationID = int(v)
		case float64:
			n.ManyRelationID = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'NotTaggedModel'", field.Name())
	}
}

// Compile time check if NotTaggedModel implements SingleRelationer interface.
var _ SingleRelationer = &NotTaggedModel{}

// GetRelationModel implements SingleRelationer interface.
func (n *NotTaggedModel) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 5: // Related
		return n.Related, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, n)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (n *NotTaggedModel) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 5: // Related
		if model == nil {
			n.Related = nil
			return nil
		} else if related, ok := model.(*OtherNotTaggedModel); ok {
			n.Related = related
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Related", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, n)
	}
}

// Compile time check if Model1WithMany2Many implements Model interface.
var _ Model = &Model1WithMany2Many{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Model1WithMany2Many'.
func (m *Model1WithMany2Many) NeuronCollectionName() string {
	return "model_1_with_many_2_manies"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *Model1WithMany2Many) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *Model1WithMany2Many) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Model1WithMany2Many'", value)
	}
	return nil
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Model1WithMany2Many{}

// AddRelationModel implements MultiRelationer interface.
func (m *Model1WithMany2Many) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Synced
		model2WithMany2Many, ok := model.(*Model2WithMany2Many)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Synced'", model)
		}
		m.Synced = append(m.Synced, model2WithMany2Many)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Model1WithMany2Many'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (m *Model1WithMany2Many) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		for _, model := range m.Synced {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (m *Model1WithMany2Many) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		if index > len(m.Synced)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'Model1WithMany2Many', Field Synced")
		}
		return m.Synced[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (m *Model1WithMany2Many) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Synced
		return len(m.Synced), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if Model2WithMany2Many implements Model interface.
var _ Model = &Model2WithMany2Many{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Model2WithMany2Many'.
func (m *Model2WithMany2Many) NeuronCollectionName() string {
	return "model_2_with_many_2_manies"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *Model2WithMany2Many) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *Model2WithMany2Many) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Model2WithMany2Many'", value)
	}
	return nil
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Model2WithMany2Many{}

// AddRelationModel implements MultiRelationer interface.
func (m *Model2WithMany2Many) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Synced
		model1WithMany2Many, ok := model.(*Model1WithMany2Many)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Synced'", model)
		}
		m.Synced = append(m.Synced, model1WithMany2Many)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Model2WithMany2Many'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (m *Model2WithMany2Many) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		for _, model := range m.Synced {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (m *Model2WithMany2Many) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		if index > len(m.Synced)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'Model2WithMany2Many', Field Synced")
		}
		return m.Synced[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (m *Model2WithMany2Many) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Synced
		return len(m.Synced), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if JoinModel implements Model interface.
var _ Model = &JoinModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'JoinModel'.
func (j *JoinModel) NeuronCollectionName() string {
	return "join_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (j *JoinModel) IsPrimaryKeyZero() bool {
	return j.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (j *JoinModel) GetPrimaryKeyValue() interface{} {
	return j.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (j *JoinModel) GetPrimaryKeyHashableValue() interface{} {
	return j.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (j *JoinModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (j *JoinModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		j.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		j.ID = int(valueType)
	case int16:
		j.ID = int(valueType)
	case int32:
		j.ID = int(valueType)
	case int64:
		j.ID = int(valueType)
	case uint:
		j.ID = int(valueType)
	case uint8:
		j.ID = int(valueType)
	case uint16:
		j.ID = int(valueType)
	case uint32:
		j.ID = int(valueType)
	case uint64:
		j.ID = int(valueType)
	case float32:
		j.ID = int(valueType)
	case float64:
		j.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'JoinModel'", value)
	}
	return nil
}

// Compile time check if JoinModel implements Fielder interface.
var _ Fielder = &JoinModel{}

// GetFieldZeroValue implements Fielder interface.s
func (j *JoinModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 2: // Model1WithMany2ManyID
		return 0, nil
	case 4: // SecondForeign
		return 0, nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (j *JoinModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 2: // Model1WithMany2ManyID
		return j.Model1WithMany2ManyID == 0, nil
	case 4: // SecondForeign
		return j.SecondForeign == 0, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (j *JoinModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 2: // Model1WithMany2ManyID
		j.Model1WithMany2ManyID = 0
	case 4: // SecondForeign
		j.SecondForeign = 0
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (j *JoinModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 2: // Model1WithMany2ManyID
		return j.Model1WithMany2ManyID, nil
	case 4: // SecondForeign
		return j.SecondForeign, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'JoinModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (j *JoinModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 2: // Model1WithMany2ManyID
		return j.Model1WithMany2ManyID, nil
	case 4: // SecondForeign
		return j.SecondForeign, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: JoinModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (j *JoinModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 2: // Model1WithMany2ManyID
		if v, ok := value.(int); ok {
			j.Model1WithMany2ManyID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			j.Model1WithMany2ManyID = int(v)
		case int16:
			j.Model1WithMany2ManyID = int(v)
		case int32:
			j.Model1WithMany2ManyID = int(v)
		case int64:
			j.Model1WithMany2ManyID = int(v)
		case uint:
			j.Model1WithMany2ManyID = int(v)
		case uint8:
			j.Model1WithMany2ManyID = int(v)
		case uint16:
			j.Model1WithMany2ManyID = int(v)
		case uint32:
			j.Model1WithMany2ManyID = int(v)
		case uint64:
			j.Model1WithMany2ManyID = int(v)
		case float32:
			j.Model1WithMany2ManyID = int(v)
		case float64:
			j.Model1WithMany2ManyID = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // SecondForeign
		if v, ok := value.(int); ok {
			j.SecondForeign = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			j.SecondForeign = int(v)
		case int16:
			j.SecondForeign = int(v)
		case int32:
			j.SecondForeign = int(v)
		case int64:
			j.SecondForeign = int(v)
		case uint:
			j.SecondForeign = int(v)
		case uint8:
			j.SecondForeign = int(v)
		case uint16:
			j.SecondForeign = int(v)
		case uint32:
			j.SecondForeign = int(v)
		case uint64:
			j.SecondForeign = int(v)
		case float32:
			j.SecondForeign = int(v)
		case float64:
			j.SecondForeign = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'JoinModel'", field.Name())
	}
}

// Compile time check if JoinModel implements SingleRelationer interface.
var _ SingleRelationer = &JoinModel{}

// GetRelationModel implements SingleRelationer interface.
func (j *JoinModel) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 1: // First
		return j.First, nil
	case 3: // Second
		return j.Second, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (j *JoinModel) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // First
		if model == nil {
			j.First = nil
			return nil
		} else if first, ok := model.(*Model1WithMany2Many); ok {
			j.First = first
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation First", model)
	case 3: // Second
		if model == nil {
			j.Second = nil
			return nil
		} else if second, ok := model.(*Model2WithMany2Many); ok {
			j.Second = second
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Second", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// Compile time check if ModelWithBelongsTo implements Model interface.
var _ Model = &ModelWithBelongsTo{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithBelongsTo'.
func (m *ModelWithBelongsTo) NeuronCollectionName() string {
	return "model_with_belongs_tos"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *ModelWithBelongsTo) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *ModelWithBelongsTo) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithBelongsTo'", value)
	}
	return nil
}

// Compile time check if ModelWithBelongsTo implements Fielder interface.
var _ Fielder = &ModelWithBelongsTo{}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithBelongsTo) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return 0, nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithBelongsTo) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return m.ForeignKey == 0, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithBelongsTo) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // ForeignKey
		m.ForeignKey = 0
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithBelongsTo) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithBelongsTo'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithBelongsTo) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelWithBelongsTo'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithBelongsTo) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		if v, ok := value.(int); ok {
			m.ForeignKey = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			m.ForeignKey = int(v)
		case int16:
			m.ForeignKey = int(v)
		case int32:
			m.ForeignKey = int(v)
		case int64:
			m.ForeignKey = int(v)
		case uint:
			m.ForeignKey = int(v)
		case uint8:
			m.ForeignKey = int(v)
		case uint16:
			m.ForeignKey = int(v)
		case uint32:
			m.ForeignKey = int(v)
		case uint64:
			m.ForeignKey = int(v)
		case float32:
			m.ForeignKey = int(v)
		case float64:
			m.ForeignKey = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithBelongsTo'", field.Name())
	}
}

// Compile time check if ModelWithBelongsTo implements SingleRelationer interface.
var _ SingleRelationer = &ModelWithBelongsTo{}

// GetRelationModel implements SingleRelationer interface.
func (m *ModelWithBelongsTo) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 2: // BelongsTo
		return m.BelongsTo, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (m *ModelWithBelongsTo) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 2: // BelongsTo
		if model == nil {
			m.BelongsTo = nil
			return nil
		} else if belongsTo, ok := model.(*ModelWithHasOne); ok {
			m.BelongsTo = belongsTo
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation BelongsTo", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if OrderModel implements Model interface.
var _ Model = &OrderModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'OrderModel'.
func (o *OrderModel) NeuronCollectionName() string {
	return "order_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (o *OrderModel) IsPrimaryKeyZero() bool {
	return o.ID == [16]byte{}
}

// GetPrimaryKeyValue implements query.Model interface method.
func (o *OrderModel) GetPrimaryKeyValue() interface{} {
	return o.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (o *OrderModel) GetPrimaryKeyHashableValue() interface{} {
	return o.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (o *OrderModel) GetPrimaryKeyZeroValue() interface{} {
	return [16]byte{}
}

// SetPrimaryKey implements query.Model interface method.
func (o *OrderModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.([16]byte); ok {
		o.ID = v
		return nil
	}
	return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, o)
}

// Compile time check if OrderModel implements Fielder interface.
var _ Fielder = &OrderModel{}

// GetFieldZeroValue implements Fielder interface.s
func (o *OrderModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return "", nil
	case 2: // First
		return "", nil
	case 3: // Second
		return 0, nil
	case 4: // Third
		return "", nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (o *OrderModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // Name
		return o.Name == "", nil
	case 2: // First
		return o.First == "", nil
	case 3: // Second
		return o.Second == 0, nil
	case 4: // Third
		return o.Third == "", nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (o *OrderModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // Name
		o.Name = ""
	case 2: // First
		o.First = ""
	case 3: // Second
		o.Second = 0
	case 4: // Third
		o.Third = ""
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (o *OrderModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return o.Name, nil
	case 2: // First
		return o.First, nil
	case 3: // Second
		return o.Second, nil
	case 4: // Third
		return o.Third, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'OrderModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (o *OrderModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return o.Name, nil
	case 2: // First
		return o.First, nil
	case 3: // Second
		return o.Second, nil
	case 4: // Third
		return o.Third, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: OrderModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (o *OrderModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // Name
		if v, ok := value.(string); ok {
			o.Name = v
			return nil
		}
		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			o.Name = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // First
		if v, ok := value.(string); ok {
			o.First = v
			return nil
		}
		// Check alternate types for the First.
		if v, ok := value.([]byte); ok {
			o.First = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Second
		if v, ok := value.(int); ok {
			o.Second = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			o.Second = int(v)
		case int16:
			o.Second = int(v)
		case int32:
			o.Second = int(v)
		case int64:
			o.Second = int(v)
		case uint:
			o.Second = int(v)
		case uint8:
			o.Second = int(v)
		case uint16:
			o.Second = int(v)
		case uint32:
			o.Second = int(v)
		case uint64:
			o.Second = int(v)
		case float32:
			o.Second = int(v)
		case float64:
			o.Second = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // Third
		if v, ok := value.(string); ok {
			o.Third = v
			return nil
		}
		// Check alternate types for the Third.
		if v, ok := value.([]byte); ok {
			o.Third = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'OrderModel'", field.Name())
	}
}

// Compile time check if InvalidCreatedAt implements Model interface.
var _ Model = &InvalidCreatedAt{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'InvalidCreatedAt'.
func (i *InvalidCreatedAt) NeuronCollectionName() string {
	return "invalid_created_ats"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (i *InvalidCreatedAt) IsPrimaryKeyZero() bool {
	return i.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyValue() interface{} {
	return i.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyHashableValue() interface{} {
	return i.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (i *InvalidCreatedAt) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		i.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		i.ID = int(valueType)
	case int16:
		i.ID = int(valueType)
	case int32:
		i.ID = int(valueType)
	case int64:
		i.ID = int(valueType)
	case uint:
		i.ID = int(valueType)
	case uint8:
		i.ID = int(valueType)
	case uint16:
		i.ID = int(valueType)
	case uint32:
		i.ID = int(valueType)
	case uint64:
		i.ID = int(valueType)
	case float32:
		i.ID = int(valueType)
	case float64:
		i.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'InvalidCreatedAt'", value)
	}
	return nil
}

// Compile time check if InvalidCreatedAt implements Fielder interface.
var _ Fielder = &InvalidCreatedAt{}

// GetFieldZeroValue implements Fielder interface.s
func (i *InvalidCreatedAt) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return "", nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (i *InvalidCreatedAt) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return i.CreatedAt == "", nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (i *InvalidCreatedAt) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // CreatedAt
		i.CreatedAt = ""
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (i *InvalidCreatedAt) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return i.CreatedAt, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'InvalidCreatedAt'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (i *InvalidCreatedAt) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return i.CreatedAt, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: InvalidCreatedAt'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (i *InvalidCreatedAt) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		if v, ok := value.(string); ok {
			i.CreatedAt = v
			return nil
		}
		// Check alternate types for the CreatedAt.
		if v, ok := value.([]byte); ok {
			i.CreatedAt = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'InvalidCreatedAt'", field.Name())
	}
}

// Compile time check if InvalidUpdatedAt implements Model interface.
var _ Model = &InvalidUpdatedAt{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'InvalidUpdatedAt'.
func (i *InvalidUpdatedAt) NeuronCollectionName() string {
	return "invalid_updated_ats"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (i *InvalidUpdatedAt) IsPrimaryKeyZero() bool {
	return i.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyValue() interface{} {
	return i.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyHashableValue() interface{} {
	return i.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (i *InvalidUpdatedAt) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		i.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		i.ID = int(valueType)
	case int16:
		i.ID = int(valueType)
	case int32:
		i.ID = int(valueType)
	case int64:
		i.ID = int(valueType)
	case uint:
		i.ID = int(valueType)
	case uint8:
		i.ID = int(valueType)
	case uint16:
		i.ID = int(valueType)
	case uint32:
		i.ID = int(valueType)
	case uint64:
		i.ID = int(valueType)
	case float32:
		i.ID = int(valueType)
	case float64:
		i.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'InvalidUpdatedAt'", value)
	}
	return nil
}

// Compile time check if InvalidUpdatedAt implements Fielder interface.
var _ Fielder = &InvalidUpdatedAt{}

// GetFieldZeroValue implements Fielder interface.s
func (i *InvalidUpdatedAt) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // UpdatedAt
		return 0, nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (i *InvalidUpdatedAt) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // UpdatedAt
		return i.UpdatedAt == 0, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (i *InvalidUpdatedAt) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // UpdatedAt
		i.UpdatedAt = 0
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (i *InvalidUpdatedAt) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // UpdatedAt
		return i.UpdatedAt, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'InvalidUpdatedAt'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (i *InvalidUpdatedAt) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // UpdatedAt
		return i.UpdatedAt, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: InvalidUpdatedAt'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (i *InvalidUpdatedAt) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // UpdatedAt
		if v, ok := value.(int); ok {
			i.UpdatedAt = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			i.UpdatedAt = int(v)
		case int16:
			i.UpdatedAt = int(v)
		case int32:
			i.UpdatedAt = int(v)
		case int64:
			i.UpdatedAt = int(v)
		case uint:
			i.UpdatedAt = int(v)
		case uint8:
			i.UpdatedAt = int(v)
		case uint16:
			i.UpdatedAt = int(v)
		case uint32:
			i.UpdatedAt = int(v)
		case uint64:
			i.UpdatedAt = int(v)
		case float32:
			i.UpdatedAt = int(v)
		case float64:
			i.UpdatedAt = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'InvalidUpdatedAt'", field.Name())
	}
}

// Compile time check if ModelWithHasMany implements Model interface.
var _ Model = &ModelWithHasMany{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithHasMany'.
func (m *ModelWithHasMany) NeuronCollectionName() string {
	return "model_with_has_manies"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *ModelWithHasMany) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *ModelWithHasMany) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithHasMany'", value)
	}
	return nil
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &ModelWithHasMany{}

// AddRelationModel implements MultiRelationer interface.
func (m *ModelWithHasMany) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // HasMany
		modelWithForeignKey, ok := model.(*ModelWithForeignKey)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'HasMany'", model)
		}
		m.HasMany = append(m.HasMany, modelWithForeignKey)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'ModelWithHasMany'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (m *ModelWithHasMany) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // HasMany
		for _, model := range m.HasMany {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (m *ModelWithHasMany) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // HasMany
		if index > len(m.HasMany)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'ModelWithHasMany', Field HasMany")
		}
		return m.HasMany[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (m *ModelWithHasMany) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // HasMany
		return len(m.HasMany), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if ModelWithForeignKey implements Model interface.
var _ Model = &ModelWithForeignKey{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithForeignKey'.
func (m *ModelWithForeignKey) NeuronCollectionName() string {
	return "model_with_foreign_keys"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *ModelWithForeignKey) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *ModelWithForeignKey) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithForeignKey'", value)
	}
	return nil
}

// Compile time check if ModelWithForeignKey implements Fielder interface.
var _ Fielder = &ModelWithForeignKey{}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithForeignKey) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return 0, nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithForeignKey) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return m.ForeignKey == 0, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithForeignKey) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // ForeignKey
		m.ForeignKey = 0
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithForeignKey) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithForeignKey'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithForeignKey) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelWithForeignKey'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithForeignKey) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // ForeignKey
		if v, ok := value.(int); ok {
			m.ForeignKey = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			m.ForeignKey = int(v)
		case int16:
			m.ForeignKey = int(v)
		case int32:
			m.ForeignKey = int(v)
		case int64:
			m.ForeignKey = int(v)
		case uint:
			m.ForeignKey = int(v)
		case uint8:
			m.ForeignKey = int(v)
		case uint16:
			m.ForeignKey = int(v)
		case uint32:
			m.ForeignKey = int(v)
		case uint64:
			m.ForeignKey = int(v)
		case float32:
			m.ForeignKey = int(v)
		case float64:
			m.ForeignKey = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithForeignKey'", field.Name())
	}
}

// Compile time check if Comment implements Model interface.
var _ Model = &Comment{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Comment'.
func (c *Comment) NeuronCollectionName() string {
	return "comments"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (c *Comment) IsPrimaryKeyZero() bool {
	return c.ID == ""
}

// GetPrimaryKeyValue implements query.Model interface method.
func (c *Comment) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (c *Comment) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (c *Comment) GetPrimaryKeyZeroValue() interface{} {
	return ""
}

// SetPrimaryKey implements query.Model interface method.
func (c *Comment) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(string); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	if v, ok := value.([]byte); ok {
		c.ID = string(v)
		return nil
	}
	return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, c)
}

// Compile time check if Comment implements Fielder interface.
var _ Fielder = &Comment{}

// GetFieldZeroValue implements Fielder interface.s
func (c *Comment) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // UpdatedAt
		return time.Time{}, nil
	case 3: // DeletedAt
		return (*time.Time)(nil), nil
	case 4: // UserID
		return "", nil
	case 6: // JobID
		return "", nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (c *Comment) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return c.CreatedAt == time.Time{}, nil
	case 2: // UpdatedAt
		return c.UpdatedAt == time.Time{}, nil
	case 3: // DeletedAt
		return c.DeletedAt == nil, nil
	case 4: // UserID
		return c.UserID == "", nil
	case 6: // JobID
		return c.JobID == "", nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (c *Comment) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // CreatedAt
		c.CreatedAt = time.Time{}
	case 2: // UpdatedAt
		c.UpdatedAt = time.Time{}
	case 3: // DeletedAt
		c.DeletedAt = nil
	case 4: // UserID
		c.UserID = ""
	case 6: // JobID
		c.JobID = ""
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (c *Comment) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return c.CreatedAt, nil
	case 2: // UpdatedAt
		return c.UpdatedAt, nil
	case 3: // DeletedAt
		if c.DeletedAt == nil {
			return c.DeletedAt, nil
		}
		return *c.DeletedAt, nil
	case 4: // UserID
		return c.UserID, nil
	case 6: // JobID
		return c.JobID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Comment'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (c *Comment) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return c.CreatedAt, nil
	case 2: // UpdatedAt
		return c.UpdatedAt, nil
	case 3: // DeletedAt
		return c.DeletedAt, nil
	case 4: // UserID
		return c.UserID, nil
	case 6: // JobID
		return c.JobID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (c *Comment) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			c.CreatedAt = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedAt
		if v, ok := value.(time.Time); ok {
			c.UpdatedAt = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedAt
		if value == nil {
			c.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			c.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			c.DeletedAt = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // UserID
		if v, ok := value.(string); ok {
			c.UserID = v
			return nil
		}
		// Check alternate types for the UserID.
		if v, ok := value.([]byte); ok {
			c.UserID = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // JobID
		if v, ok := value.(string); ok {
			c.JobID = v
			return nil
		}
		// Check alternate types for the JobID.
		if v, ok := value.([]byte); ok {
			c.JobID = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Comment'", field.Name())
	}
}

// Compile time check if Comment implements SingleRelationer interface.
var _ SingleRelationer = &Comment{}

// GetRelationModel implements SingleRelationer interface.
func (c *Comment) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 5: // User
		return c.User, nil
	case 7: // Job
		return c.Job, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (c *Comment) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 5: // User
		if model == nil {
			c.User = nil
			return nil
		} else if user, ok := model.(*User); ok {
			c.User = user
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation User", model)
	case 7: // Job
		if model == nil {
			c.Job = nil
			return nil
		} else if job, ok := model.(*Job); ok {
			c.Job = job
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Job", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// Compile time check if Job implements Model interface.
var _ Model = &Job{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Job'.
func (j *Job) NeuronCollectionName() string {
	return "jobs"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (j *Job) IsPrimaryKeyZero() bool {
	return j.ID == ""
}

// GetPrimaryKeyValue implements query.Model interface method.
func (j *Job) GetPrimaryKeyValue() interface{} {
	return j.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (j *Job) GetPrimaryKeyHashableValue() interface{} {
	return j.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (j *Job) GetPrimaryKeyZeroValue() interface{} {
	return ""
}

// SetPrimaryKey implements query.Model interface method.
func (j *Job) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(string); ok {
		j.ID = v
		return nil
	}
	// Check alternate types for given field.
	if v, ok := value.([]byte); ok {
		j.ID = string(v)
		return nil
	}
	return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, j)
}

// Compile time check if Job implements Fielder interface.
var _ Fielder = &Job{}

// GetFieldZeroValue implements Fielder interface.s
func (j *Job) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // UpdatedAt
		return time.Time{}, nil
	case 3: // DeletedAt
		return (*time.Time)(nil), nil
	case 4: // StartAt
		return (*time.Time)(nil), nil
	case 5: // EndAt
		return (*time.Time)(nil), nil
	case 6: // Title
		return "", nil
	case 7: // CreatorID
		return "", nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (j *Job) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return j.CreatedAt == time.Time{}, nil
	case 2: // UpdatedAt
		return j.UpdatedAt == time.Time{}, nil
	case 3: // DeletedAt
		return j.DeletedAt == nil, nil
	case 4: // StartAt
		return j.StartAt == nil, nil
	case 5: // EndAt
		return j.EndAt == nil, nil
	case 6: // Title
		return j.Title == "", nil
	case 7: // CreatorID
		return j.CreatorID == "", nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (j *Job) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // CreatedAt
		j.CreatedAt = time.Time{}
	case 2: // UpdatedAt
		j.UpdatedAt = time.Time{}
	case 3: // DeletedAt
		j.DeletedAt = nil
	case 4: // StartAt
		j.StartAt = nil
	case 5: // EndAt
		j.EndAt = nil
	case 6: // Title
		j.Title = ""
	case 7: // CreatorID
		j.CreatorID = ""
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (j *Job) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return j.CreatedAt, nil
	case 2: // UpdatedAt
		return j.UpdatedAt, nil
	case 3: // DeletedAt
		if j.DeletedAt == nil {
			return j.DeletedAt, nil
		}
		return *j.DeletedAt, nil
	case 4: // StartAt
		if j.StartAt == nil {
			return j.StartAt, nil
		}
		return *j.StartAt, nil
	case 5: // EndAt
		if j.EndAt == nil {
			return j.EndAt, nil
		}
		return *j.EndAt, nil
	case 6: // Title
		return j.Title, nil
	case 7: // CreatorID
		return j.CreatorID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Job'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (j *Job) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		return j.CreatedAt, nil
	case 2: // UpdatedAt
		return j.UpdatedAt, nil
	case 3: // DeletedAt
		return j.DeletedAt, nil
	case 4: // StartAt
		return j.StartAt, nil
	case 5: // EndAt
		return j.EndAt, nil
	case 6: // Title
		return j.Title, nil
	case 7: // CreatorID
		return j.CreatorID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: Job'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (j *Job) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			j.CreatedAt = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedAt
		if v, ok := value.(time.Time); ok {
			j.UpdatedAt = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedAt
		if value == nil {
			j.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			j.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			j.DeletedAt = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // StartAt
		if value == nil {
			j.StartAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			j.StartAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			j.StartAt = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 5: // EndAt
		if value == nil {
			j.EndAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			j.EndAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			j.EndAt = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // Title
		if v, ok := value.(string); ok {
			j.Title = v
			return nil
		}
		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			j.Title = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 7: // CreatorID
		if v, ok := value.(string); ok {
			j.CreatorID = v
			return nil
		}
		// Check alternate types for the CreatorID.
		if v, ok := value.([]byte); ok {
			j.CreatorID = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Job'", field.Name())
	}
}

// Compile time check if Job implements SingleRelationer interface.
var _ SingleRelationer = &Job{}

// GetRelationModel implements SingleRelationer interface.
func (j *Job) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 8: // Creator
		return j.Creator, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (j *Job) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 8: // Creator
		if model == nil {
			j.Creator = nil
			return nil
		} else if creator, ok := model.(*User); ok {
			j.Creator = creator
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Creator", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Job{}

// AddRelationModel implements MultiRelationer interface.
func (j *Job) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 9: // Comments
		comment, ok := model.(*Comment)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Comments'", model)
		}
		j.Comments = append(j.Comments, comment)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Job'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (j *Job) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 9: // Comments
		for _, model := range j.Comments {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (j *Job) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 9: // Comments
		if index > len(j.Comments)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'Job', Field Comments")
		}
		return j.Comments[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (j *Job) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 9: // Comments
		return len(j.Comments), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// Compile time check if TModel implements Model interface.
var _ Model = &TModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'TModel'.
func (t *TModel) NeuronCollectionName() string {
	return "t_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (t *TModel) IsPrimaryKeyZero() bool {
	return t.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (t *TModel) GetPrimaryKeyValue() interface{} {
	return t.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (t *TModel) GetPrimaryKeyHashableValue() interface{} {
	return t.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (t *TModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (t *TModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		t.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		t.ID = int(valueType)
	case int16:
		t.ID = int(valueType)
	case int32:
		t.ID = int(valueType)
	case int64:
		t.ID = int(valueType)
	case uint:
		t.ID = int(valueType)
	case uint8:
		t.ID = int(valueType)
	case uint16:
		t.ID = int(valueType)
	case uint32:
		t.ID = int(valueType)
	case uint64:
		t.ID = int(valueType)
	case float32:
		t.ID = int(valueType)
	case float64:
		t.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'TModel'", value)
	}
	return nil
}

// Compile time check if TModel implements Fielder interface.
var _ Fielder = &TModel{}

// GetFieldZeroValue implements Fielder interface.s
func (t *TModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedTime
		return time.Time{}, nil
	case 2: // UpdatedTime
		return (*time.Time)(nil), nil
	case 3: // DeletedTime
		return (*time.Time)(nil), nil
	case 4: // Number
		return 0, nil
	case 5: // String
		return "", nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (t *TModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // CreatedTime
		return t.CreatedTime == time.Time{}, nil
	case 2: // UpdatedTime
		return t.UpdatedTime == nil, nil
	case 3: // DeletedTime
		return t.DeletedTime == nil, nil
	case 4: // Number
		return t.Number == 0, nil
	case 5: // String
		return t.String == "", nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (t *TModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // CreatedTime
		t.CreatedTime = time.Time{}
	case 2: // UpdatedTime
		t.UpdatedTime = nil
	case 3: // DeletedTime
		t.DeletedTime = nil
	case 4: // Number
		t.Number = 0
	case 5: // String
		t.String = ""
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (t *TModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedTime
		return t.CreatedTime, nil
	case 2: // UpdatedTime
		if t.UpdatedTime == nil {
			return t.UpdatedTime, nil
		}
		return *t.UpdatedTime, nil
	case 3: // DeletedTime
		if t.DeletedTime == nil {
			return t.DeletedTime, nil
		}
		return *t.DeletedTime, nil
	case 4: // Number
		return t.Number, nil
	case 5: // String
		return t.String, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'TModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (t *TModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // CreatedTime
		return t.CreatedTime, nil
	case 2: // UpdatedTime
		return t.UpdatedTime, nil
	case 3: // DeletedTime
		return t.DeletedTime, nil
	case 4: // Number
		return t.Number, nil
	case 5: // String
		return t.String, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: TModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (t *TModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // CreatedTime
		if v, ok := value.(time.Time); ok {
			t.CreatedTime = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedTime
		if value == nil {
			t.UpdatedTime = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			t.UpdatedTime = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			t.UpdatedTime = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedTime
		if value == nil {
			t.DeletedTime = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			t.DeletedTime = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			t.DeletedTime = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // Number
		if v, ok := value.(int); ok {
			t.Number = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			t.Number = int(v)
		case int16:
			t.Number = int(v)
		case int32:
			t.Number = int(v)
		case int64:
			t.Number = int(v)
		case uint:
			t.Number = int(v)
		case uint8:
			t.Number = int(v)
		case uint16:
			t.Number = int(v)
		case uint32:
			t.Number = int(v)
		case uint64:
			t.Number = int(v)
		case float32:
			t.Number = int(v)
		case float64:
			t.Number = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 5: // String
		if v, ok := value.(string); ok {
			t.String = v
			return nil
		}
		// Check alternate types for the String.
		if v, ok := value.([]byte); ok {
			t.String = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'TModel'", field.Name())
	}
}

// Compile time check if BenchModel implements Model interface.
var _ Model = &BenchModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'BenchModel'.
func (b *BenchModel) NeuronCollectionName() string {
	return "bench_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (b *BenchModel) IsPrimaryKeyZero() bool {
	return b.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (b *BenchModel) GetPrimaryKeyValue() interface{} {
	return b.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (b *BenchModel) GetPrimaryKeyHashableValue() interface{} {
	return b.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (b *BenchModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (b *BenchModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		b.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		b.ID = int(valueType)
	case int16:
		b.ID = int(valueType)
	case int32:
		b.ID = int(valueType)
	case int64:
		b.ID = int(valueType)
	case uint:
		b.ID = int(valueType)
	case uint8:
		b.ID = int(valueType)
	case uint16:
		b.ID = int(valueType)
	case uint32:
		b.ID = int(valueType)
	case uint64:
		b.ID = int(valueType)
	case float32:
		b.ID = int(valueType)
	case float64:
		b.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'BenchModel'", value)
	}
	return nil
}

// Compile time check if BenchModel implements Fielder interface.
var _ Fielder = &BenchModel{}

// GetFieldZeroValue implements Fielder interface.s
func (b *BenchModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return "", nil
	case 2: // First
		return "", nil
	case 3: // Second
		return 0, nil
	case 4: // Third
		return "", nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (b *BenchModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // Name
		return b.Name == "", nil
	case 2: // First
		return b.First == "", nil
	case 3: // Second
		return b.Second == 0, nil
	case 4: // Third
		return b.Third == "", nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (b *BenchModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // Name
		b.Name = ""
	case 2: // First
		b.First = ""
	case 3: // Second
		b.Second = 0
	case 4: // Third
		b.Third = ""
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (b *BenchModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return b.Name, nil
	case 2: // First
		return b.First, nil
	case 3: // Second
		return b.Second, nil
	case 4: // Third
		return b.Third, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'BenchModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (b *BenchModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // Name
		return b.Name, nil
	case 2: // First
		return b.First, nil
	case 3: // Second
		return b.Second, nil
	case 4: // Third
		return b.Third, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: BenchModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (b *BenchModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // Name
		if v, ok := value.(string); ok {
			b.Name = v
			return nil
		}
		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			b.Name = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // First
		if v, ok := value.(string); ok {
			b.First = v
			return nil
		}
		// Check alternate types for the First.
		if v, ok := value.([]byte); ok {
			b.First = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Second
		if v, ok := value.(int); ok {
			b.Second = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			b.Second = int(v)
		case int16:
			b.Second = int(v)
		case int32:
			b.Second = int(v)
		case int64:
			b.Second = int(v)
		case uint:
			b.Second = int(v)
		case uint8:
			b.Second = int(v)
		case uint16:
			b.Second = int(v)
		case uint32:
			b.Second = int(v)
		case uint64:
			b.Second = int(v)
		case float32:
			b.Second = int(v)
		case float64:
			b.Second = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // Third
		if v, ok := value.(string); ok {
			b.Third = v
			return nil
		}
		// Check alternate types for the Third.
		if v, ok := value.([]byte); ok {
			b.Third = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'BenchModel'", field.Name())
	}
}

// Compile time check if Timer implements Model interface.
var _ Model = &Timer{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Timer'.
func (t *Timer) NeuronCollectionName() string {
	return "timers"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (t *Timer) IsPrimaryKeyZero() bool {
	return t.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (t *Timer) GetPrimaryKeyValue() interface{} {
	return t.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (t *Timer) GetPrimaryKeyHashableValue() interface{} {
	return t.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (t *Timer) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (t *Timer) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		t.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		t.ID = int(valueType)
	case int16:
		t.ID = int(valueType)
	case int32:
		t.ID = int(valueType)
	case int64:
		t.ID = int(valueType)
	case uint:
		t.ID = int(valueType)
	case uint8:
		t.ID = int(valueType)
	case uint16:
		t.ID = int(valueType)
	case uint32:
		t.ID = int(valueType)
	case uint64:
		t.ID = int(valueType)
	case float32:
		t.ID = int(valueType)
	case float64:
		t.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Timer'", value)
	}
	return nil
}

// Compile time check if InvalidDeletedAt implements Model interface.
var _ Model = &InvalidDeletedAt{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'InvalidDeletedAt'.
func (i *InvalidDeletedAt) NeuronCollectionName() string {
	return "invalid_deleted_ats"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (i *InvalidDeletedAt) IsPrimaryKeyZero() bool {
	return i.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyValue() interface{} {
	return i.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyHashableValue() interface{} {
	return i.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (i *InvalidDeletedAt) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		i.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		i.ID = int(valueType)
	case int16:
		i.ID = int(valueType)
	case int32:
		i.ID = int(valueType)
	case int64:
		i.ID = int(valueType)
	case uint:
		i.ID = int(valueType)
	case uint8:
		i.ID = int(valueType)
	case uint16:
		i.ID = int(valueType)
	case uint32:
		i.ID = int(valueType)
	case uint64:
		i.ID = int(valueType)
	case float32:
		i.ID = int(valueType)
	case float64:
		i.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'InvalidDeletedAt'", value)
	}
	return nil
}

// Compile time check if Second implements Model interface.
var _ Model = &Second{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Second'.
func (s *Second) NeuronCollectionName() string {
	return "seconds"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (s *Second) IsPrimaryKeyZero() bool {
	return s.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (s *Second) GetPrimaryKeyValue() interface{} {
	return s.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (s *Second) GetPrimaryKeyHashableValue() interface{} {
	return s.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (s *Second) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (s *Second) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		s.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		s.ID = int(valueType)
	case int16:
		s.ID = int(valueType)
	case int32:
		s.ID = int(valueType)
	case int64:
		s.ID = int(valueType)
	case uint:
		s.ID = int(valueType)
	case uint8:
		s.ID = int(valueType)
	case uint16:
		s.ID = int(valueType)
	case uint32:
		s.ID = int(valueType)
	case uint64:
		s.ID = int(valueType)
	case float32:
		s.ID = int(valueType)
	case float64:
		s.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Second'", value)
	}
	return nil
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Second{}

// AddRelationModel implements MultiRelationer interface.
func (s *Second) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Firsts
		first, ok := model.(*First)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Firsts'", model)
		}
		s.Firsts = append(s.Firsts, first)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Second'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (s *Second) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Firsts
		for _, model := range s.Firsts {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, s)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (s *Second) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Firsts
		if index > len(s.Firsts)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'Second', Field Firsts")
		}
		return s.Firsts[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, s)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (s *Second) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Firsts
		return len(s.Firsts), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, s)
	}
}

// Compile time check if User implements Model interface.
var _ Model = &User{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'User'.
func (u *User) NeuronCollectionName() string {
	return "users"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (u *User) IsPrimaryKeyZero() bool {
	return u.ID == ""
}

// GetPrimaryKeyValue implements query.Model interface method.
func (u *User) GetPrimaryKeyValue() interface{} {
	return u.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (u *User) GetPrimaryKeyHashableValue() interface{} {
	return u.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (u *User) GetPrimaryKeyZeroValue() interface{} {
	return ""
}

// SetPrimaryKey implements query.Model interface method.
func (u *User) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(string); ok {
		u.ID = v
		return nil
	}
	// Check alternate types for given field.
	if v, ok := value.([]byte); ok {
		u.ID = string(v)
		return nil
	}
	return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, u)
}

// Compile time check if User implements Fielder interface.
var _ Fielder = &User{}

// GetFieldZeroValue implements Fielder interface.s
func (u *User) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 2: // CreatedAt
		return time.Time{}, nil
	case 3: // UpdatedAt
		return time.Time{}, nil
	case 4: // DeletedAt
		return (*time.Time)(nil), nil
	case 5: // FirstName
		return "", nil
	case 6: // LastName
		return "", nil
	case 7: // Email
		return "", nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (u *User) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 2: // CreatedAt
		return u.CreatedAt == time.Time{}, nil
	case 3: // UpdatedAt
		return u.UpdatedAt == time.Time{}, nil
	case 4: // DeletedAt
		return u.DeletedAt == nil, nil
	case 5: // FirstName
		return u.FirstName == "", nil
	case 6: // LastName
		return u.LastName == "", nil
	case 7: // Email
		return u.Email == "", nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (u *User) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 2: // CreatedAt
		u.CreatedAt = time.Time{}
	case 3: // UpdatedAt
		u.UpdatedAt = time.Time{}
	case 4: // DeletedAt
		u.DeletedAt = nil
	case 5: // FirstName
		u.FirstName = ""
	case 6: // LastName
		u.LastName = ""
	case 7: // Email
		u.Email = ""
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (u *User) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 2: // CreatedAt
		return u.CreatedAt, nil
	case 3: // UpdatedAt
		return u.UpdatedAt, nil
	case 4: // DeletedAt
		if u.DeletedAt == nil {
			return u.DeletedAt, nil
		}
		return *u.DeletedAt, nil
	case 5: // FirstName
		return u.FirstName, nil
	case 6: // LastName
		return u.LastName, nil
	case 7: // Email
		return u.Email, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'User'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (u *User) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 2: // CreatedAt
		return u.CreatedAt, nil
	case 3: // UpdatedAt
		return u.UpdatedAt, nil
	case 4: // DeletedAt
		return u.DeletedAt, nil
	case 5: // FirstName
		return u.FirstName, nil
	case 6: // LastName
		return u.LastName, nil
	case 7: // Email
		return u.Email, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (u *User) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 2: // CreatedAt
		if v, ok := value.(time.Time); ok {
			u.CreatedAt = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // UpdatedAt
		if v, ok := value.(time.Time); ok {
			u.UpdatedAt = v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // DeletedAt
		if value == nil {
			u.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			u.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			u.DeletedAt = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 5: // FirstName
		if v, ok := value.(string); ok {
			u.FirstName = v
			return nil
		}
		// Check alternate types for the FirstName.
		if v, ok := value.([]byte); ok {
			u.FirstName = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // LastName
		if v, ok := value.(string); ok {
			u.LastName = v
			return nil
		}
		// Check alternate types for the LastName.
		if v, ok := value.([]byte); ok {
			u.LastName = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 7: // Email
		if v, ok := value.(string); ok {
			u.Email = v
			return nil
		}
		// Check alternate types for the Email.
		if v, ok := value.([]byte); ok {
			u.Email = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'User'", field.Name())
	}
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &User{}

// AddRelationModel implements MultiRelationer interface.
func (u *User) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Cars
		car, ok := model.(*Car)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Cars'", model)
		}
		u.Cars = append(u.Cars, car)
	case 8: // Jobs
		job, ok := model.(*Job)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Jobs'", model)
		}
		u.Jobs = append(u.Jobs, job)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'User'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (u *User) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Cars
		for _, model := range u.Cars {
			models = append(models, model)
		}
	case 8: // Jobs
		for _, model := range u.Jobs {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (u *User) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Cars
		if index > len(u.Cars)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'User', Field Cars")
		}
		return u.Cars[index], nil
	case 8: // Jobs
		if index > len(u.Jobs)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'User', Field Jobs")
		}
		return u.Jobs[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (u *User) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Cars
		return len(u.Cars), nil
	case 8: // Jobs
		return len(u.Jobs), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// Compile time check if CarBrand implements Model interface.
var _ Model = &CarBrand{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'CarBrand'.
func (c *CarBrand) NeuronCollectionName() string {
	return "car_brands"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (c *CarBrand) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (c *CarBrand) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (c *CarBrand) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (c *CarBrand) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (c *CarBrand) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'CarBrand'", value)
	}
	return nil
}

// Compile time check if Car implements Model interface.
var _ Model = &Car{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Car'.
func (c *Car) NeuronCollectionName() string {
	return "cars"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (c *Car) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (c *Car) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (c *Car) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (c *Car) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (c *Car) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'Car'", value)
	}
	return nil
}

// Compile time check if Car implements Fielder interface.
var _ Fielder = &Car{}

// GetFieldZeroValue implements Fielder interface.s
func (c *Car) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // UserID
		return "", nil
	case 3: // BrandID
		return 0, nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (c *Car) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // UserID
		return c.UserID == "", nil
	case 3: // BrandID
		return c.BrandID == 0, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (c *Car) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // UserID
		c.UserID = ""
	case 3: // BrandID
		c.BrandID = 0
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (c *Car) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // UserID
		return c.UserID, nil
	case 3: // BrandID
		return c.BrandID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Car'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (c *Car) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // UserID
		return c.UserID, nil
	case 3: // BrandID
		return c.BrandID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: Car'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (c *Car) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // UserID
		if v, ok := value.(string); ok {
			c.UserID = v
			return nil
		}
		// Check alternate types for the UserID.
		if v, ok := value.([]byte); ok {
			c.UserID = string(v)
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // BrandID
		if v, ok := value.(int); ok {
			c.BrandID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			c.BrandID = int(v)
		case int16:
			c.BrandID = int(v)
		case int32:
			c.BrandID = int(v)
		case int64:
			c.BrandID = int(v)
		case uint:
			c.BrandID = int(v)
		case uint8:
			c.BrandID = int(v)
		case uint16:
			c.BrandID = int(v)
		case uint32:
			c.BrandID = int(v)
		case uint64:
			c.BrandID = int(v)
		case float32:
			c.BrandID = int(v)
		case float64:
			c.BrandID = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Car'", field.Name())
	}
}

// Compile time check if Car implements SingleRelationer interface.
var _ SingleRelationer = &Car{}

// GetRelationModel implements SingleRelationer interface.
func (c *Car) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 2: // Brand
		return c.Brand, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (c *Car) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 2: // Brand
		if model == nil {
			c.Brand = nil
			return nil
		} else if brand, ok := model.(*CarBrand); ok {
			c.Brand = brand
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation Brand", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// Compile time check if ModelWithNested implements Model interface.
var _ Model = &ModelWithNested{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithNested'.
func (m *ModelWithNested) NeuronCollectionName() string {
	return "model_with_nesteds"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *ModelWithNested) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *ModelWithNested) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *ModelWithNested) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *ModelWithNested) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *ModelWithNested) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithNested'", value)
	}
	return nil
}

// Compile time check if ModelWithNested implements Fielder interface.
var _ Fielder = &ModelWithNested{}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithNested) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // PtrComposed
		return (*NestedAttribute)(nil), nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithNested) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // PtrComposed
		return m.PtrComposed == nil, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithNested) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // PtrComposed
		m.PtrComposed = nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithNested) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // PtrComposed
		if m.PtrComposed == nil {
			return m.PtrComposed, nil
		}
		return *m.PtrComposed, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithNested'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithNested) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // PtrComposed
		return m.PtrComposed, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelWithNested'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithNested) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // PtrComposed
		if value == nil {
			m.PtrComposed = nil
			return nil
		}
		if v, ok := value.(*NestedAttribute); ok {
			m.PtrComposed = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(NestedAttribute); ok {
			m.PtrComposed = &v
			return nil
		}
		return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithNested'", field.Name())
	}
}

// Compile time check if First implements Model interface.
var _ Model = &First{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'First'.
func (f *First) NeuronCollectionName() string {
	return "firsts"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (f *First) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (f *First) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (f *First) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (f *First) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (f *First) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'First'", value)
	}
	return nil
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &First{}

// AddRelationModel implements MultiRelationer interface.
func (f *First) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Many
		second, ok := model.(*Second)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Many'", model)
		}
		f.Many = append(f.Many, second)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'First'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (f *First) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Many
		for _, model := range f.Many {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (f *First) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Many
		if index > len(f.Many)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'First', Field Many")
		}
		return f.Many[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (f *First) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Many
		return len(f.Many), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
}

// Compile time check if FirstSeconds implements Model interface.
var _ Model = &FirstSeconds{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'FirstSeconds'.
func (f *FirstSeconds) NeuronCollectionName() string {
	return "first_seconds"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (f *FirstSeconds) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (f *FirstSeconds) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (f *FirstSeconds) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (f *FirstSeconds) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (f *FirstSeconds) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'FirstSeconds'", value)
	}
	return nil
}

// Compile time check if FirstSeconds implements Fielder interface.
var _ Fielder = &FirstSeconds{}

// GetFieldZeroValue implements Fielder interface.s
func (f *FirstSeconds) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // FirstID
		return 0, nil
	case 2: // SecondID
		return 0, nil
	default:
		return nil, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (f *FirstSeconds) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // FirstID
		return f.FirstID == 0, nil
	case 2: // SecondID
		return f.SecondID == 0, nil
	}
	return false, errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (f *FirstSeconds) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 1: // FirstID
		f.FirstID = 0
	case 2: // SecondID
		f.SecondID = 0
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (f *FirstSeconds) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // FirstID
		return f.FirstID, nil
	case 2: // SecondID
		return f.SecondID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: 'FirstSeconds'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (f *FirstSeconds) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // FirstID
		return f.FirstID, nil
	case 2: // SecondID
		return f.SecondID, nil
	}
	return nil, errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for given model: FirstSeconds'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (f *FirstSeconds) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // FirstID
		if v, ok := value.(int); ok {
			f.FirstID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.FirstID = int(v)
		case int16:
			f.FirstID = int(v)
		case int32:
			f.FirstID = int(v)
		case int64:
			f.FirstID = int(v)
		case uint:
			f.FirstID = int(v)
		case uint8:
			f.FirstID = int(v)
		case uint16:
			f.FirstID = int(v)
		case uint32:
			f.FirstID = int(v)
		case uint64:
			f.FirstID = int(v)
		case float32:
			f.FirstID = int(v)
		case float64:
			f.FirstID = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // SecondID
		if v, ok := value.(int); ok {
			f.SecondID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			f.SecondID = int(v)
		case int16:
			f.SecondID = int(v)
		case int32:
			f.SecondID = int(v)
		case int64:
			f.SecondID = int(v)
		case uint:
			f.SecondID = int(v)
		case uint8:
			f.SecondID = int(v)
		case uint16:
			f.SecondID = int(v)
		case uint32:
			f.SecondID = int(v)
		case uint64:
			f.SecondID = int(v)
		case float32:
			f.SecondID = int(v)
		case float64:
			f.SecondID = int(v)
		default:
			return errors.Newf(ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(ClassInvalidModelField, "provided invalid field: '%s' for the model: 'FirstSeconds'", field.Name())
	}
}

// Compile time check if ModelWithHasOne implements Model interface.
var _ Model = &ModelWithHasOne{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithHasOne'.
func (m *ModelWithHasOne) NeuronCollectionName() string {
	return "model_with_has_ones"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (m *ModelWithHasOne) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (m *ModelWithHasOne) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithHasOne'", value)
	}
	return nil
}

// Compile time check if ModelWithHasOne implements SingleRelationer interface.
var _ SingleRelationer = &ModelWithHasOne{}

// GetRelationModel implements SingleRelationer interface.
func (m *ModelWithHasOne) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 1: // HasOne
		return m.HasOne, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (m *ModelWithHasOne) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // HasOne
		if model == nil {
			m.HasOne = nil
			return nil
		} else if hasOne, ok := model.(*ModelWithBelongsTo); ok {
			m.HasOne = hasOne
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation HasOne", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if OtherNotTaggedModel implements Model interface.
var _ Model = &OtherNotTaggedModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'OtherNotTaggedModel'.
func (o *OtherNotTaggedModel) NeuronCollectionName() string {
	return "other_not_tagged_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (o *OtherNotTaggedModel) IsPrimaryKeyZero() bool {
	return o.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyValue() interface{} {
	return o.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyHashableValue() interface{} {
	return o.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (o *OtherNotTaggedModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		o.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		o.ID = int(valueType)
	case int16:
		o.ID = int(valueType)
	case int32:
		o.ID = int(valueType)
	case int64:
		o.ID = int(valueType)
	case uint:
		o.ID = int(valueType)
	case uint8:
		o.ID = int(valueType)
	case uint16:
		o.ID = int(valueType)
	case uint32:
		o.ID = int(valueType)
	case uint64:
		o.ID = int(valueType)
	case float32:
		o.ID = int(valueType)
	case float64:
		o.ID = int(valueType)
	default:
		return errors.Newf(ClassInvalidFieldValue, "provided invalid value: '%T' for the primary field for model: 'OtherNotTaggedModel'", value)
	}
	return nil
}

// Compile time check if OtherNotTaggedModel implements SingleRelationer interface.
var _ SingleRelationer = &OtherNotTaggedModel{}

// GetRelationModel implements SingleRelationer interface.
func (o *OtherNotTaggedModel) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 1: // SingleRelated
		return o.SingleRelated, nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (o *OtherNotTaggedModel) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // SingleRelated
		if model == nil {
			o.SingleRelated = nil
			return nil
		} else if singleRelated, ok := model.(*NotTaggedModel); ok {
			o.SingleRelated = singleRelated
			return nil
		}
		return errors.Newf(ClassInvalidRelationValue, "provided invalid model value: '%T' for relation SingleRelated", model)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &OtherNotTaggedModel{}

// AddRelationModel implements MultiRelationer interface.
func (o *OtherNotTaggedModel) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 2: // ManyRelation
		notTaggedModel, ok := model.(*NotTaggedModel)
		if !ok {
			return errors.Newf(ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'ManyRelation'", model)
		}
		o.ManyRelation = append(o.ManyRelation, notTaggedModel)
	default:
		return errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'OtherNotTaggedModel'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (o *OtherNotTaggedModel) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 2: // ManyRelation
		for _, model := range o.ManyRelation {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (o *OtherNotTaggedModel) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 2: // ManyRelation
		if index > len(o.ManyRelation)-1 {
			return nil, errors.Newf(ClassInvalidRelationIndex, "index out of possible range. Model: 'OtherNotTaggedModel', Field ManyRelation")
		}
		return o.ManyRelation[index], nil
	default:
		return nil, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (o *OtherNotTaggedModel) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 2: // ManyRelation
		return len(o.ManyRelation), nil
	default:
		return 0, errors.Newf(ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
}
