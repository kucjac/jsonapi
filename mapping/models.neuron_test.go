// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Mon, 27 Jul 2020 20:45:37 +0200

package mapping

import (
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/neuronlabs/neuron/errors"
)

// Neuron_Models stores all generated models in this package.
var Neuron_Models = []Model{
	&BenchModel{},
	&Car{},
	&CarBrand{},
	&Comment{},
	&First{},
	&FirstSeconds{},
	&InvalidCreatedAt{},
	&InvalidDeletedAt{},
	&InvalidUpdatedAt{},
	&Job{},
	&JoinModel{},
	&Model1WithMany2Many{},
	&Model2WithMany2Many{},
	&ModelWithBelongsTo{},
	&ModelWithForeignKey{},
	&ModelWithHasMany{},
	&ModelWithHasOne{},
	&ModelWithNested{},
	&NotTaggedModel{},
	&OrderModel{},
	&OtherNotTaggedModel{},
	&Second{},
	&TModel{},
	&Timer{},
	&User{},
}

// Compile time check if BenchModel implements Model interface.
var _ Model = &BenchModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'BenchModel'.
func (b *BenchModel) NeuronCollectionName() string {
	return "bench_models"
}

// IsPrimaryKeyZero implements Model interface method.
func (b *BenchModel) IsPrimaryKeyZero() bool {
	return b.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (b *BenchModel) GetPrimaryKeyValue() interface{} {
	return b.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (b *BenchModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(b.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (b *BenchModel) GetPrimaryKeyAddress() interface{} {
	return &b.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (b *BenchModel) GetPrimaryKeyHashableValue() interface{} {
	return b.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (b *BenchModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (b *BenchModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		b.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		b.ID = int(valueType)
	case int16:
		b.ID = int(valueType)
	case int32:
		b.ID = int(valueType)
	case int64:
		b.ID = int(valueType)
	case uint:
		b.ID = int(valueType)
	case uint8:
		b.ID = int(valueType)
	case uint16:
		b.ID = int(valueType)
	case uint32:
		b.ID = int(valueType)
	case uint64:
		b.ID = int(valueType)
	case float32:
		b.ID = int(valueType)
	case float64:
		b.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'BenchModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (b *BenchModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	b.ID = int(tmp)
	return nil
}

// Compile time check if BenchModel implements Fielder interface.
var _ Fielder = &BenchModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (b *BenchModel) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &b.ID, nil
	case 1: // Name
		return &b.Name, nil
	case 2: // First
		return &b.First, nil
	case 3: // Second
		return &b.Second, nil
	case 4: // Third
		return &b.Third, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: BenchModel'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (b *BenchModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Name
		return "", nil
	case 2: // First
		return "", nil
	case 3: // Second
		return 0, nil
	case 4: // Third
		return "", nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (b *BenchModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID == 0, nil
	case 1: // Name
		return b.Name == "", nil
	case 2: // First
		return b.First == "", nil
	case 3: // Second
		return b.Second == 0, nil
	case 4: // Third
		return b.Third == "", nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (b *BenchModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		b.ID = 0
	case 1: // Name
		b.Name = ""
	case 2: // First
		b.First = ""
	case 3: // Second
		b.Second = 0
	case 4: // Third
		b.Third = ""
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (b *BenchModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // Name
		return b.Name, nil
	case 2: // First
		return b.First, nil
	case 3: // Second
		return b.Second, nil
	case 4: // Third
		return b.Third, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'BenchModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (b *BenchModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // Name
		return b.Name, nil
	case 2: // First
		return b.First, nil
	case 3: // Second
		return b.Second, nil
	case 4: // Third
		return b.Third, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: BenchModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (b *BenchModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			b.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			b.ID = int(v)
		case int16:
			b.ID = int(v)
		case int32:
			b.ID = int(v)
		case int64:
			b.ID = int(v)
		case uint:
			b.ID = int(v)
		case uint8:
			b.ID = int(v)
		case uint16:
			b.ID = int(v)
		case uint32:
			b.ID = int(v)
		case uint64:
			b.ID = int(v)
		case float32:
			b.ID = int(v)
		case float64:
			b.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Name
		if v, ok := value.(string); ok {
			b.Name = v
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			b.Name = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // First
		if v, ok := value.(string); ok {
			b.First = v
			return nil
		}

		// Check alternate types for the First.
		if v, ok := value.([]byte); ok {
			b.First = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Second
		if v, ok := value.(int); ok {
			b.Second = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			b.Second = int(v)
		case int16:
			b.Second = int(v)
		case int32:
			b.Second = int(v)
		case int64:
			b.Second = int(v)
		case uint:
			b.Second = int(v)
		case uint8:
			b.Second = int(v)
		case uint16:
			b.Second = int(v)
		case uint32:
			b.Second = int(v)
		case uint64:
			b.Second = int(v)
		case float32:
			b.Second = int(v)
		case float64:
			b.Second = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // Third
		if v, ok := value.(string); ok {
			b.Third = v
			return nil
		}

		// Check alternate types for the Third.
		if v, ok := value.([]byte); ok {
			b.Third = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'BenchModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (b *BenchModel) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // Name
		return value, nil
	case 2: // First
		return value, nil
	case 3: // Second
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 4: // Third
		return value, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: BenchModel'", field.Name())
}

// Compile time check if Car implements Model interface.
var _ Model = &Car{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Car'.
func (c *Car) NeuronCollectionName() string {
	return "cars"
}

// IsPrimaryKeyZero implements Model interface method.
func (c *Car) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (c *Car) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (c *Car) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(c.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (c *Car) GetPrimaryKeyAddress() interface{} {
	return &c.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (c *Car) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (c *Car) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (c *Car) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Car'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (c *Car) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	c.ID = int(tmp)
	return nil
}

// Compile time check if Car implements Fielder interface.
var _ Fielder = &Car{}

// GetFieldsAddress gets the address of provided 'field'.
func (c *Car) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &c.ID, nil
	case 1: // UserID
		return &c.UserID, nil
	case 3: // BrandID
		return &c.BrandID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Car'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (c *Car) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // UserID
		return "", nil
	case 3: // BrandID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (c *Car) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID == 0, nil
	case 1: // UserID
		return c.UserID == "", nil
	case 3: // BrandID
		return c.BrandID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (c *Car) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		c.ID = 0
	case 1: // UserID
		c.UserID = ""
	case 3: // BrandID
		c.BrandID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (c *Car) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // UserID
		return c.UserID, nil
	case 3: // BrandID
		return c.BrandID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Car'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (c *Car) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // UserID
		return c.UserID, nil
	case 3: // BrandID
		return c.BrandID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Car'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (c *Car) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			c.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			c.ID = int(v)
		case int16:
			c.ID = int(v)
		case int32:
			c.ID = int(v)
		case int64:
			c.ID = int(v)
		case uint:
			c.ID = int(v)
		case uint8:
			c.ID = int(v)
		case uint16:
			c.ID = int(v)
		case uint32:
			c.ID = int(v)
		case uint64:
			c.ID = int(v)
		case float32:
			c.ID = int(v)
		case float64:
			c.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // UserID
		if v, ok := value.(string); ok {
			c.UserID = v
			return nil
		}

		// Check alternate types for the UserID.
		if v, ok := value.([]byte); ok {
			c.UserID = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // BrandID
		if v, ok := value.(int); ok {
			c.BrandID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			c.BrandID = int(v)
		case int16:
			c.BrandID = int(v)
		case int32:
			c.BrandID = int(v)
		case int64:
			c.BrandID = int(v)
		case uint:
			c.BrandID = int(v)
		case uint8:
			c.BrandID = int(v)
		case uint16:
			c.BrandID = int(v)
		case uint32:
			c.BrandID = int(v)
		case uint64:
			c.BrandID = int(v)
		case float32:
			c.BrandID = int(v)
		case float64:
			c.BrandID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Car'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (c *Car) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // UserID
		return value, nil
	case 3: // BrandID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Car'", field.Name())
}

// Compile time check if Car implements SingleRelationer interface.
var _ SingleRelationer = &Car{}

// GetRelationModel implements SingleRelationer interface.
func (c *Car) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 2: // Brand
		if c.Brand == nil {
			return nil, nil
		}
		return c.Brand, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (c *Car) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 2: // Brand
		if model == nil {
			c.Brand = nil
			return nil
		} else if brand, ok := model.(*CarBrand); ok {
			c.Brand = brand
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Brand", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// Compile time check if CarBrand implements Model interface.
var _ Model = &CarBrand{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'CarBrand'.
func (c *CarBrand) NeuronCollectionName() string {
	return "car_brands"
}

// IsPrimaryKeyZero implements Model interface method.
func (c *CarBrand) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (c *CarBrand) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (c *CarBrand) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(c.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (c *CarBrand) GetPrimaryKeyAddress() interface{} {
	return &c.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (c *CarBrand) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (c *CarBrand) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (c *CarBrand) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'CarBrand'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (c *CarBrand) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	c.ID = int(tmp)
	return nil
}

// Compile time check if CarBrand implements Fielder interface.
var _ Fielder = &CarBrand{}

// GetFieldsAddress gets the address of provided 'field'.
func (c *CarBrand) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &c.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: CarBrand'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (c *CarBrand) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (c *CarBrand) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (c *CarBrand) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		c.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (c *CarBrand) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'CarBrand'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (c *CarBrand) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: CarBrand'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (c *CarBrand) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			c.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			c.ID = int(v)
		case int16:
			c.ID = int(v)
		case int32:
			c.ID = int(v)
		case int64:
			c.ID = int(v)
		case uint:
			c.ID = int(v)
		case uint8:
			c.ID = int(v)
		case uint16:
			c.ID = int(v)
		case uint32:
			c.ID = int(v)
		case uint64:
			c.ID = int(v)
		case float32:
			c.ID = int(v)
		case float64:
			c.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'CarBrand'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (c *CarBrand) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: CarBrand'", field.Name())
}

// Compile time check if Comment implements Model interface.
var _ Model = &Comment{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Comment'.
func (c *Comment) NeuronCollectionName() string {
	return "comments"
}

// IsPrimaryKeyZero implements Model interface method.
func (c *Comment) IsPrimaryKeyZero() bool {
	return c.ID == ""
}

// GetPrimaryKeyValue implements Model interface method.
func (c *Comment) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (c *Comment) GetPrimaryKeyStringValue() (string, error) {
	return c.ID, nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (c *Comment) GetPrimaryKeyAddress() interface{} {
	return &c.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (c *Comment) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (c *Comment) GetPrimaryKeyZeroValue() interface{} {
	return ""
}

// SetPrimaryKey implements Model interface method.
func (c *Comment) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(string); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	if v, ok := value.([]byte); ok {
		c.ID = string(v)
		return nil
	}
	return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, c)
}

// SetPrimaryKeyStringValue implements Model interface method.
func (c *Comment) SetPrimaryKeyStringValue(value string) error {
	c.ID = value
	return nil
}

// Compile time check if Comment implements Fielder interface.
var _ Fielder = &Comment{}

// GetFieldsAddress gets the address of provided 'field'.
func (c *Comment) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &c.ID, nil
	case 1: // CreatedAt
		return &c.CreatedAt, nil
	case 2: // UpdatedAt
		return &c.UpdatedAt, nil
	case 3: // DeletedAt
		return &c.DeletedAt, nil
	case 4: // UserID
		return &c.UserID, nil
	case 6: // JobID
		return &c.JobID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (c *Comment) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return "", nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // UpdatedAt
		return time.Time{}, nil
	case 3: // DeletedAt
		return nil, nil
	case 4: // UserID
		return "", nil
	case 6: // JobID
		return "", nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (c *Comment) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID == "", nil
	case 1: // CreatedAt
		return c.CreatedAt == time.Time{}, nil
	case 2: // UpdatedAt
		return c.UpdatedAt == time.Time{}, nil
	case 3: // DeletedAt
		return c.DeletedAt == nil, nil
	case 4: // UserID
		return c.UserID == "", nil
	case 6: // JobID
		return c.JobID == "", nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (c *Comment) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		c.ID = ""
	case 1: // CreatedAt
		c.CreatedAt = time.Time{}
	case 2: // UpdatedAt
		c.UpdatedAt = time.Time{}
	case 3: // DeletedAt
		c.DeletedAt = nil
	case 4: // UserID
		c.UserID = ""
	case 6: // JobID
		c.JobID = ""
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (c *Comment) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // CreatedAt
		return c.CreatedAt, nil
	case 2: // UpdatedAt
		return c.UpdatedAt, nil
	case 3: // DeletedAt
		if c.DeletedAt == nil {
			return nil, nil
		}
		return *c.DeletedAt, nil
	case 4: // UserID
		return c.UserID, nil
	case 6: // JobID
		return c.JobID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Comment'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (c *Comment) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // CreatedAt
		return c.CreatedAt, nil
	case 2: // UpdatedAt
		return c.UpdatedAt, nil
	case 3: // DeletedAt
		return c.DeletedAt, nil
	case 4: // UserID
		return c.UserID, nil
	case 6: // JobID
		return c.JobID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (c *Comment) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(string); ok {
			c.ID = v
			return nil
		}

		// Check alternate types for the ID.
		if v, ok := value.([]byte); ok {
			c.ID = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			c.CreatedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedAt
		if v, ok := value.(time.Time); ok {
			c.UpdatedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedAt
		if value == nil {
			c.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			c.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			c.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // UserID
		if v, ok := value.(string); ok {
			c.UserID = v
			return nil
		}

		// Check alternate types for the UserID.
		if v, ok := value.([]byte); ok {
			c.UserID = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // JobID
		if v, ok := value.(string); ok {
			c.JobID = v
			return nil
		}

		// Check alternate types for the JobID.
		if v, ok := value.([]byte); ok {
			c.JobID = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Comment'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (c *Comment) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return value, nil
	case 1: // CreatedAt
		temp := c.CreatedAt
		if err := c.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", c.CreatedAt, err)
		}
		bt, err := c.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", c.CreatedAt, err)
		}
		c.CreatedAt = temp
		return string(bt), nil
	case 2: // UpdatedAt
		temp := c.UpdatedAt
		if err := c.UpdatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", c.UpdatedAt, err)
		}
		bt, err := c.UpdatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", c.UpdatedAt, err)
		}
		c.UpdatedAt = temp
		return string(bt), nil
	case 3: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", c.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", c.DeletedAt, err)
		}

		return string(bt), nil
	case 4: // UserID
		return value, nil
	case 6: // JobID
		return value, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// Compile time check if Comment implements SingleRelationer interface.
var _ SingleRelationer = &Comment{}

// GetRelationModel implements SingleRelationer interface.
func (c *Comment) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 5: // User
		if c.User == nil {
			return nil, nil
		}
		return c.User, nil
	case 7: // Job
		if c.Job == nil {
			return nil, nil
		}
		return c.Job, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (c *Comment) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 5: // User
		if model == nil {
			c.User = nil
			return nil
		} else if user, ok := model.(*User); ok {
			c.User = user
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation User", model)
	case 7: // Job
		if model == nil {
			c.Job = nil
			return nil
		} else if job, ok := model.(*Job); ok {
			c.Job = job
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Job", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, c)
	}
}

// Compile time check if First implements Model interface.
var _ Model = &First{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'First'.
func (f *First) NeuronCollectionName() string {
	return "firsts"
}

// IsPrimaryKeyZero implements Model interface method.
func (f *First) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (f *First) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (f *First) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(f.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (f *First) GetPrimaryKeyAddress() interface{} {
	return &f.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (f *First) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (f *First) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (f *First) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'First'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (f *First) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	f.ID = int(tmp)
	return nil
}

// Compile time check if First implements Fielder interface.
var _ Fielder = &First{}

// GetFieldsAddress gets the address of provided 'field'.
func (f *First) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &f.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: First'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (f *First) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (f *First) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (f *First) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		f.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (f *First) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'First'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (f *First) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: First'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (f *First) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			f.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			f.ID = int(v)
		case int16:
			f.ID = int(v)
		case int32:
			f.ID = int(v)
		case int64:
			f.ID = int(v)
		case uint:
			f.ID = int(v)
		case uint8:
			f.ID = int(v)
		case uint16:
			f.ID = int(v)
		case uint32:
			f.ID = int(v)
		case uint64:
			f.ID = int(v)
		case float32:
			f.ID = int(v)
		case float64:
			f.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'First'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (f *First) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: First'", field.Name())
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &First{}

// AddRelationModel implements MultiRelationer interface.
func (f *First) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Many
		second, ok := model.(*Second)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Many'", model)
		}
		f.Many = append(f.Many, second)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'First'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (f *First) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Many
		for _, model := range f.Many {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (f *First) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Many
		if index > len(f.Many)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'First', Field Many")
		}
		return f.Many[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (f *First) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Many
		return len(f.Many), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, f)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (f *First) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 1: // Many
		temp := make([]*Second, len(models))
		for i, model := range models {
			second, ok := model.(*Second)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Many'", model)
			}
			temp[i] = second
		}
		f.Many = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'First'", relation.String())
	}
	return nil
}

// Compile time check if FirstSeconds implements Model interface.
var _ Model = &FirstSeconds{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'FirstSeconds'.
func (f *FirstSeconds) NeuronCollectionName() string {
	return "first_seconds"
}

// IsPrimaryKeyZero implements Model interface method.
func (f *FirstSeconds) IsPrimaryKeyZero() bool {
	return f.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (f *FirstSeconds) GetPrimaryKeyValue() interface{} {
	return f.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (f *FirstSeconds) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(f.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (f *FirstSeconds) GetPrimaryKeyAddress() interface{} {
	return &f.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (f *FirstSeconds) GetPrimaryKeyHashableValue() interface{} {
	return f.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (f *FirstSeconds) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (f *FirstSeconds) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		f.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		f.ID = int(valueType)
	case int16:
		f.ID = int(valueType)
	case int32:
		f.ID = int(valueType)
	case int64:
		f.ID = int(valueType)
	case uint:
		f.ID = int(valueType)
	case uint8:
		f.ID = int(valueType)
	case uint16:
		f.ID = int(valueType)
	case uint32:
		f.ID = int(valueType)
	case uint64:
		f.ID = int(valueType)
	case float32:
		f.ID = int(valueType)
	case float64:
		f.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'FirstSeconds'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (f *FirstSeconds) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	f.ID = int(tmp)
	return nil
}

// Compile time check if FirstSeconds implements Fielder interface.
var _ Fielder = &FirstSeconds{}

// GetFieldsAddress gets the address of provided 'field'.
func (f *FirstSeconds) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &f.ID, nil
	case 1: // FirstID
		return &f.FirstID, nil
	case 2: // SecondID
		return &f.SecondID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: FirstSeconds'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (f *FirstSeconds) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // FirstID
		return 0, nil
	case 2: // SecondID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (f *FirstSeconds) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID == 0, nil
	case 1: // FirstID
		return f.FirstID == 0, nil
	case 2: // SecondID
		return f.SecondID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (f *FirstSeconds) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		f.ID = 0
	case 1: // FirstID
		f.FirstID = 0
	case 2: // SecondID
		f.SecondID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (f *FirstSeconds) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 1: // FirstID
		return f.FirstID, nil
	case 2: // SecondID
		return f.SecondID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'FirstSeconds'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (f *FirstSeconds) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return f.ID, nil
	case 1: // FirstID
		return f.FirstID, nil
	case 2: // SecondID
		return f.SecondID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: FirstSeconds'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (f *FirstSeconds) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			f.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			f.ID = int(v)
		case int16:
			f.ID = int(v)
		case int32:
			f.ID = int(v)
		case int64:
			f.ID = int(v)
		case uint:
			f.ID = int(v)
		case uint8:
			f.ID = int(v)
		case uint16:
			f.ID = int(v)
		case uint32:
			f.ID = int(v)
		case uint64:
			f.ID = int(v)
		case float32:
			f.ID = int(v)
		case float64:
			f.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // FirstID
		if v, ok := value.(int); ok {
			f.FirstID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			f.FirstID = int(v)
		case int16:
			f.FirstID = int(v)
		case int32:
			f.FirstID = int(v)
		case int64:
			f.FirstID = int(v)
		case uint:
			f.FirstID = int(v)
		case uint8:
			f.FirstID = int(v)
		case uint16:
			f.FirstID = int(v)
		case uint32:
			f.FirstID = int(v)
		case uint64:
			f.FirstID = int(v)
		case float32:
			f.FirstID = int(v)
		case float64:
			f.FirstID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // SecondID
		if v, ok := value.(int); ok {
			f.SecondID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			f.SecondID = int(v)
		case int16:
			f.SecondID = int(v)
		case int32:
			f.SecondID = int(v)
		case int64:
			f.SecondID = int(v)
		case uint:
			f.SecondID = int(v)
		case uint8:
			f.SecondID = int(v)
		case uint16:
			f.SecondID = int(v)
		case uint32:
			f.SecondID = int(v)
		case uint64:
			f.SecondID = int(v)
		case float32:
			f.SecondID = int(v)
		case float64:
			f.SecondID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'FirstSeconds'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (f *FirstSeconds) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // FirstID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 2: // SecondID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: FirstSeconds'", field.Name())
}

// Compile time check if InvalidCreatedAt implements Model interface.
var _ Model = &InvalidCreatedAt{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'InvalidCreatedAt'.
func (i *InvalidCreatedAt) NeuronCollectionName() string {
	return "invalid_created_ats"
}

// IsPrimaryKeyZero implements Model interface method.
func (i *InvalidCreatedAt) IsPrimaryKeyZero() bool {
	return i.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyValue() interface{} {
	return i.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(i.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyAddress() interface{} {
	return &i.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyHashableValue() interface{} {
	return i.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (i *InvalidCreatedAt) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (i *InvalidCreatedAt) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		i.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		i.ID = int(valueType)
	case int16:
		i.ID = int(valueType)
	case int32:
		i.ID = int(valueType)
	case int64:
		i.ID = int(valueType)
	case uint:
		i.ID = int(valueType)
	case uint8:
		i.ID = int(valueType)
	case uint16:
		i.ID = int(valueType)
	case uint32:
		i.ID = int(valueType)
	case uint64:
		i.ID = int(valueType)
	case float32:
		i.ID = int(valueType)
	case float64:
		i.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'InvalidCreatedAt'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidCreatedAt) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	i.ID = int(tmp)
	return nil
}

// Compile time check if InvalidCreatedAt implements Fielder interface.
var _ Fielder = &InvalidCreatedAt{}

// GetFieldsAddress gets the address of provided 'field'.
func (i *InvalidCreatedAt) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &i.ID, nil
	case 1: // CreatedAt
		return &i.CreatedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidCreatedAt'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (i *InvalidCreatedAt) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // CreatedAt
		return "", nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (i *InvalidCreatedAt) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID == 0, nil
	case 1: // CreatedAt
		return i.CreatedAt == "", nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (i *InvalidCreatedAt) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		i.ID = 0
	case 1: // CreatedAt
		i.CreatedAt = ""
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (i *InvalidCreatedAt) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID, nil
	case 1: // CreatedAt
		return i.CreatedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'InvalidCreatedAt'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (i *InvalidCreatedAt) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID, nil
	case 1: // CreatedAt
		return i.CreatedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidCreatedAt'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (i *InvalidCreatedAt) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			i.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			i.ID = int(v)
		case int16:
			i.ID = int(v)
		case int32:
			i.ID = int(v)
		case int64:
			i.ID = int(v)
		case uint:
			i.ID = int(v)
		case uint8:
			i.ID = int(v)
		case uint16:
			i.ID = int(v)
		case uint32:
			i.ID = int(v)
		case uint64:
			i.ID = int(v)
		case float32:
			i.ID = int(v)
		case float64:
			i.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // CreatedAt
		if v, ok := value.(string); ok {
			i.CreatedAt = v
			return nil
		}

		// Check alternate types for the CreatedAt.
		if v, ok := value.([]byte); ok {
			i.CreatedAt = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'InvalidCreatedAt'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidCreatedAt) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // CreatedAt
		return value, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidCreatedAt'", field.Name())
}

// Compile time check if InvalidDeletedAt implements Model interface.
var _ Model = &InvalidDeletedAt{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'InvalidDeletedAt'.
func (i *InvalidDeletedAt) NeuronCollectionName() string {
	return "invalid_deleted_ats"
}

// IsPrimaryKeyZero implements Model interface method.
func (i *InvalidDeletedAt) IsPrimaryKeyZero() bool {
	return i.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyValue() interface{} {
	return i.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(i.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyAddress() interface{} {
	return &i.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyHashableValue() interface{} {
	return i.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (i *InvalidDeletedAt) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (i *InvalidDeletedAt) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		i.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		i.ID = int(valueType)
	case int16:
		i.ID = int(valueType)
	case int32:
		i.ID = int(valueType)
	case int64:
		i.ID = int(valueType)
	case uint:
		i.ID = int(valueType)
	case uint8:
		i.ID = int(valueType)
	case uint16:
		i.ID = int(valueType)
	case uint32:
		i.ID = int(valueType)
	case uint64:
		i.ID = int(valueType)
	case float32:
		i.ID = int(valueType)
	case float64:
		i.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'InvalidDeletedAt'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidDeletedAt) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	i.ID = int(tmp)
	return nil
}

// Compile time check if InvalidDeletedAt implements Fielder interface.
var _ Fielder = &InvalidDeletedAt{}

// GetFieldsAddress gets the address of provided 'field'.
func (i *InvalidDeletedAt) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &i.ID, nil
	case 1: // DeletedAt
		return &i.DeletedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidDeletedAt'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (i *InvalidDeletedAt) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // DeletedAt
		return time.Time{}, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (i *InvalidDeletedAt) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID == 0, nil
	case 1: // DeletedAt
		return i.DeletedAt == time.Time{}, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (i *InvalidDeletedAt) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		i.ID = 0
	case 1: // DeletedAt
		i.DeletedAt = time.Time{}
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (i *InvalidDeletedAt) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID, nil
	case 1: // DeletedAt
		return i.DeletedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'InvalidDeletedAt'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (i *InvalidDeletedAt) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID, nil
	case 1: // DeletedAt
		return i.DeletedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidDeletedAt'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (i *InvalidDeletedAt) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			i.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			i.ID = int(v)
		case int16:
			i.ID = int(v)
		case int32:
			i.ID = int(v)
		case int64:
			i.ID = int(v)
		case uint:
			i.ID = int(v)
		case uint8:
			i.ID = int(v)
		case uint16:
			i.ID = int(v)
		case uint32:
			i.ID = int(v)
		case uint64:
			i.ID = int(v)
		case float32:
			i.ID = int(v)
		case float64:
			i.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // DeletedAt
		if v, ok := value.(time.Time); ok {
			i.DeletedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'InvalidDeletedAt'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidDeletedAt) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // DeletedAt
		temp := i.DeletedAt
		if err := i.DeletedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", i.DeletedAt, err)
		}
		bt, err := i.DeletedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", i.DeletedAt, err)
		}
		i.DeletedAt = temp
		return string(bt), nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidDeletedAt'", field.Name())
}

// Compile time check if InvalidUpdatedAt implements Model interface.
var _ Model = &InvalidUpdatedAt{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'InvalidUpdatedAt'.
func (i *InvalidUpdatedAt) NeuronCollectionName() string {
	return "invalid_updated_ats"
}

// IsPrimaryKeyZero implements Model interface method.
func (i *InvalidUpdatedAt) IsPrimaryKeyZero() bool {
	return i.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyValue() interface{} {
	return i.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(i.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyAddress() interface{} {
	return &i.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyHashableValue() interface{} {
	return i.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (i *InvalidUpdatedAt) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (i *InvalidUpdatedAt) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		i.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		i.ID = int(valueType)
	case int16:
		i.ID = int(valueType)
	case int32:
		i.ID = int(valueType)
	case int64:
		i.ID = int(valueType)
	case uint:
		i.ID = int(valueType)
	case uint8:
		i.ID = int(valueType)
	case uint16:
		i.ID = int(valueType)
	case uint32:
		i.ID = int(valueType)
	case uint64:
		i.ID = int(valueType)
	case float32:
		i.ID = int(valueType)
	case float64:
		i.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'InvalidUpdatedAt'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidUpdatedAt) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	i.ID = int(tmp)
	return nil
}

// Compile time check if InvalidUpdatedAt implements Fielder interface.
var _ Fielder = &InvalidUpdatedAt{}

// GetFieldsAddress gets the address of provided 'field'.
func (i *InvalidUpdatedAt) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &i.ID, nil
	case 1: // UpdatedAt
		return &i.UpdatedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidUpdatedAt'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (i *InvalidUpdatedAt) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // UpdatedAt
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (i *InvalidUpdatedAt) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID == 0, nil
	case 1: // UpdatedAt
		return i.UpdatedAt == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (i *InvalidUpdatedAt) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		i.ID = 0
	case 1: // UpdatedAt
		i.UpdatedAt = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (i *InvalidUpdatedAt) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID, nil
	case 1: // UpdatedAt
		return i.UpdatedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'InvalidUpdatedAt'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (i *InvalidUpdatedAt) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return i.ID, nil
	case 1: // UpdatedAt
		return i.UpdatedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidUpdatedAt'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (i *InvalidUpdatedAt) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			i.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			i.ID = int(v)
		case int16:
			i.ID = int(v)
		case int32:
			i.ID = int(v)
		case int64:
			i.ID = int(v)
		case uint:
			i.ID = int(v)
		case uint8:
			i.ID = int(v)
		case uint16:
			i.ID = int(v)
		case uint32:
			i.ID = int(v)
		case uint64:
			i.ID = int(v)
		case float32:
			i.ID = int(v)
		case float64:
			i.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // UpdatedAt
		if v, ok := value.(int); ok {
			i.UpdatedAt = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			i.UpdatedAt = int(v)
		case int16:
			i.UpdatedAt = int(v)
		case int32:
			i.UpdatedAt = int(v)
		case int64:
			i.UpdatedAt = int(v)
		case uint:
			i.UpdatedAt = int(v)
		case uint8:
			i.UpdatedAt = int(v)
		case uint16:
			i.UpdatedAt = int(v)
		case uint32:
			i.UpdatedAt = int(v)
		case uint64:
			i.UpdatedAt = int(v)
		case float32:
			i.UpdatedAt = int(v)
		case float64:
			i.UpdatedAt = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'InvalidUpdatedAt'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (i *InvalidUpdatedAt) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // UpdatedAt
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: InvalidUpdatedAt'", field.Name())
}

// Compile time check if Job implements Model interface.
var _ Model = &Job{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Job'.
func (j *Job) NeuronCollectionName() string {
	return "jobs"
}

// IsPrimaryKeyZero implements Model interface method.
func (j *Job) IsPrimaryKeyZero() bool {
	return j.ID == ""
}

// GetPrimaryKeyValue implements Model interface method.
func (j *Job) GetPrimaryKeyValue() interface{} {
	return j.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (j *Job) GetPrimaryKeyStringValue() (string, error) {
	return j.ID, nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (j *Job) GetPrimaryKeyAddress() interface{} {
	return &j.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (j *Job) GetPrimaryKeyHashableValue() interface{} {
	return j.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (j *Job) GetPrimaryKeyZeroValue() interface{} {
	return ""
}

// SetPrimaryKey implements Model interface method.
func (j *Job) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(string); ok {
		j.ID = v
		return nil
	}
	// Check alternate types for given field.
	if v, ok := value.([]byte); ok {
		j.ID = string(v)
		return nil
	}
	return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, j)
}

// SetPrimaryKeyStringValue implements Model interface method.
func (j *Job) SetPrimaryKeyStringValue(value string) error {
	j.ID = value
	return nil
}

// Compile time check if Job implements Fielder interface.
var _ Fielder = &Job{}

// GetFieldsAddress gets the address of provided 'field'.
func (j *Job) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &j.ID, nil
	case 1: // CreatedAt
		return &j.CreatedAt, nil
	case 2: // UpdatedAt
		return &j.UpdatedAt, nil
	case 3: // DeletedAt
		return &j.DeletedAt, nil
	case 4: // StartAt
		return &j.StartAt, nil
	case 5: // EndAt
		return &j.EndAt, nil
	case 6: // Title
		return &j.Title, nil
	case 7: // CreatorID
		return &j.CreatorID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Job'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (j *Job) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return "", nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // UpdatedAt
		return time.Time{}, nil
	case 3: // DeletedAt
		return nil, nil
	case 4: // StartAt
		return nil, nil
	case 5: // EndAt
		return nil, nil
	case 6: // Title
		return "", nil
	case 7: // CreatorID
		return "", nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (j *Job) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID == "", nil
	case 1: // CreatedAt
		return j.CreatedAt == time.Time{}, nil
	case 2: // UpdatedAt
		return j.UpdatedAt == time.Time{}, nil
	case 3: // DeletedAt
		return j.DeletedAt == nil, nil
	case 4: // StartAt
		return j.StartAt == nil, nil
	case 5: // EndAt
		return j.EndAt == nil, nil
	case 6: // Title
		return j.Title == "", nil
	case 7: // CreatorID
		return j.CreatorID == "", nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (j *Job) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		j.ID = ""
	case 1: // CreatedAt
		j.CreatedAt = time.Time{}
	case 2: // UpdatedAt
		j.UpdatedAt = time.Time{}
	case 3: // DeletedAt
		j.DeletedAt = nil
	case 4: // StartAt
		j.StartAt = nil
	case 5: // EndAt
		j.EndAt = nil
	case 6: // Title
		j.Title = ""
	case 7: // CreatorID
		j.CreatorID = ""
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (j *Job) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID, nil
	case 1: // CreatedAt
		return j.CreatedAt, nil
	case 2: // UpdatedAt
		return j.UpdatedAt, nil
	case 3: // DeletedAt
		if j.DeletedAt == nil {
			return nil, nil
		}
		return *j.DeletedAt, nil
	case 4: // StartAt
		if j.StartAt == nil {
			return nil, nil
		}
		return *j.StartAt, nil
	case 5: // EndAt
		if j.EndAt == nil {
			return nil, nil
		}
		return *j.EndAt, nil
	case 6: // Title
		return j.Title, nil
	case 7: // CreatorID
		return j.CreatorID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Job'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (j *Job) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID, nil
	case 1: // CreatedAt
		return j.CreatedAt, nil
	case 2: // UpdatedAt
		return j.UpdatedAt, nil
	case 3: // DeletedAt
		return j.DeletedAt, nil
	case 4: // StartAt
		return j.StartAt, nil
	case 5: // EndAt
		return j.EndAt, nil
	case 6: // Title
		return j.Title, nil
	case 7: // CreatorID
		return j.CreatorID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Job'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (j *Job) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(string); ok {
			j.ID = v
			return nil
		}

		// Check alternate types for the ID.
		if v, ok := value.([]byte); ok {
			j.ID = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			j.CreatedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedAt
		if v, ok := value.(time.Time); ok {
			j.UpdatedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedAt
		if value == nil {
			j.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			j.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			j.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // StartAt
		if value == nil {
			j.StartAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			j.StartAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			j.StartAt = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 5: // EndAt
		if value == nil {
			j.EndAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			j.EndAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			j.EndAt = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // Title
		if v, ok := value.(string); ok {
			j.Title = v
			return nil
		}

		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			j.Title = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 7: // CreatorID
		if v, ok := value.(string); ok {
			j.CreatorID = v
			return nil
		}

		// Check alternate types for the CreatorID.
		if v, ok := value.([]byte); ok {
			j.CreatorID = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Job'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (j *Job) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return value, nil
	case 1: // CreatedAt
		temp := j.CreatedAt
		if err := j.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", j.CreatedAt, err)
		}
		bt, err := j.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", j.CreatedAt, err)
		}
		j.CreatedAt = temp
		return string(bt), nil
	case 2: // UpdatedAt
		temp := j.UpdatedAt
		if err := j.UpdatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", j.UpdatedAt, err)
		}
		bt, err := j.UpdatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", j.UpdatedAt, err)
		}
		j.UpdatedAt = temp
		return string(bt), nil
	case 3: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", j.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", j.DeletedAt, err)
		}

		return string(bt), nil
	case 4: // StartAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'StartAt' value: '%v' to parse string. Err: %v", j.StartAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'StartAt' value: '%v' to parse string. Err: %v", j.StartAt, err)
		}

		return string(bt), nil
	case 5: // EndAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'EndAt' value: '%v' to parse string. Err: %v", j.EndAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'EndAt' value: '%v' to parse string. Err: %v", j.EndAt, err)
		}

		return string(bt), nil
	case 6: // Title
		return value, nil
	case 7: // CreatorID
		return value, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Job'", field.Name())
}

// Compile time check if Job implements SingleRelationer interface.
var _ SingleRelationer = &Job{}

// GetRelationModel implements SingleRelationer interface.
func (j *Job) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 8: // Creator
		if j.Creator == nil {
			return nil, nil
		}
		return j.Creator, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (j *Job) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 8: // Creator
		if model == nil {
			j.Creator = nil
			return nil
		} else if creator, ok := model.(*User); ok {
			j.Creator = creator
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Creator", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Job{}

// AddRelationModel implements MultiRelationer interface.
func (j *Job) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 9: // Comments
		comment, ok := model.(*Comment)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Comments'", model)
		}
		j.Comments = append(j.Comments, comment)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'Job'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (j *Job) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 9: // Comments
		for _, model := range j.Comments {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (j *Job) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 9: // Comments
		if index > len(j.Comments)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'Job', Field Comments")
		}
		return j.Comments[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (j *Job) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 9: // Comments
		return len(j.Comments), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (j *Job) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 9: // Comments
		temp := make([]*Comment, len(models))
		for i, model := range models {
			comment, ok := model.(*Comment)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Comments'", model)
			}
			temp[i] = comment
		}
		j.Comments = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'Job'", relation.String())
	}
	return nil
}

// Compile time check if JoinModel implements Model interface.
var _ Model = &JoinModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'JoinModel'.
func (j *JoinModel) NeuronCollectionName() string {
	return "join_models"
}

// IsPrimaryKeyZero implements Model interface method.
func (j *JoinModel) IsPrimaryKeyZero() bool {
	return j.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (j *JoinModel) GetPrimaryKeyValue() interface{} {
	return j.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (j *JoinModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(j.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (j *JoinModel) GetPrimaryKeyAddress() interface{} {
	return &j.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (j *JoinModel) GetPrimaryKeyHashableValue() interface{} {
	return j.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (j *JoinModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (j *JoinModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		j.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		j.ID = int(valueType)
	case int16:
		j.ID = int(valueType)
	case int32:
		j.ID = int(valueType)
	case int64:
		j.ID = int(valueType)
	case uint:
		j.ID = int(valueType)
	case uint8:
		j.ID = int(valueType)
	case uint16:
		j.ID = int(valueType)
	case uint32:
		j.ID = int(valueType)
	case uint64:
		j.ID = int(valueType)
	case float32:
		j.ID = int(valueType)
	case float64:
		j.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'JoinModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (j *JoinModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	j.ID = int(tmp)
	return nil
}

// Compile time check if JoinModel implements Fielder interface.
var _ Fielder = &JoinModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (j *JoinModel) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &j.ID, nil
	case 2: // Model1WithMany2ManyID
		return &j.Model1WithMany2ManyID, nil
	case 4: // SecondForeign
		return &j.SecondForeign, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: JoinModel'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (j *JoinModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 2: // Model1WithMany2ManyID
		return 0, nil
	case 4: // SecondForeign
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (j *JoinModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID == 0, nil
	case 2: // Model1WithMany2ManyID
		return j.Model1WithMany2ManyID == 0, nil
	case 4: // SecondForeign
		return j.SecondForeign == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (j *JoinModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		j.ID = 0
	case 2: // Model1WithMany2ManyID
		j.Model1WithMany2ManyID = 0
	case 4: // SecondForeign
		j.SecondForeign = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (j *JoinModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID, nil
	case 2: // Model1WithMany2ManyID
		return j.Model1WithMany2ManyID, nil
	case 4: // SecondForeign
		return j.SecondForeign, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'JoinModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (j *JoinModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return j.ID, nil
	case 2: // Model1WithMany2ManyID
		return j.Model1WithMany2ManyID, nil
	case 4: // SecondForeign
		return j.SecondForeign, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: JoinModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (j *JoinModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			j.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			j.ID = int(v)
		case int16:
			j.ID = int(v)
		case int32:
			j.ID = int(v)
		case int64:
			j.ID = int(v)
		case uint:
			j.ID = int(v)
		case uint8:
			j.ID = int(v)
		case uint16:
			j.ID = int(v)
		case uint32:
			j.ID = int(v)
		case uint64:
			j.ID = int(v)
		case float32:
			j.ID = int(v)
		case float64:
			j.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // Model1WithMany2ManyID
		if v, ok := value.(int); ok {
			j.Model1WithMany2ManyID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			j.Model1WithMany2ManyID = int(v)
		case int16:
			j.Model1WithMany2ManyID = int(v)
		case int32:
			j.Model1WithMany2ManyID = int(v)
		case int64:
			j.Model1WithMany2ManyID = int(v)
		case uint:
			j.Model1WithMany2ManyID = int(v)
		case uint8:
			j.Model1WithMany2ManyID = int(v)
		case uint16:
			j.Model1WithMany2ManyID = int(v)
		case uint32:
			j.Model1WithMany2ManyID = int(v)
		case uint64:
			j.Model1WithMany2ManyID = int(v)
		case float32:
			j.Model1WithMany2ManyID = int(v)
		case float64:
			j.Model1WithMany2ManyID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // SecondForeign
		if v, ok := value.(int); ok {
			j.SecondForeign = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			j.SecondForeign = int(v)
		case int16:
			j.SecondForeign = int(v)
		case int32:
			j.SecondForeign = int(v)
		case int64:
			j.SecondForeign = int(v)
		case uint:
			j.SecondForeign = int(v)
		case uint8:
			j.SecondForeign = int(v)
		case uint16:
			j.SecondForeign = int(v)
		case uint32:
			j.SecondForeign = int(v)
		case uint64:
			j.SecondForeign = int(v)
		case float32:
			j.SecondForeign = int(v)
		case float64:
			j.SecondForeign = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'JoinModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (j *JoinModel) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 2: // Model1WithMany2ManyID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 4: // SecondForeign
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: JoinModel'", field.Name())
}

// Compile time check if JoinModel implements SingleRelationer interface.
var _ SingleRelationer = &JoinModel{}

// GetRelationModel implements SingleRelationer interface.
func (j *JoinModel) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 1: // First
		if j.First == nil {
			return nil, nil
		}
		return j.First, nil
	case 3: // Second
		if j.Second == nil {
			return nil, nil
		}
		return j.Second, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (j *JoinModel) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // First
		if model == nil {
			j.First = nil
			return nil
		} else if first, ok := model.(*Model1WithMany2Many); ok {
			j.First = first
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation First", model)
	case 3: // Second
		if model == nil {
			j.Second = nil
			return nil
		} else if second, ok := model.(*Model2WithMany2Many); ok {
			j.Second = second
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Second", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, j)
	}
}

// Compile time check if Model1WithMany2Many implements Model interface.
var _ Model = &Model1WithMany2Many{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Model1WithMany2Many'.
func (m *Model1WithMany2Many) NeuronCollectionName() string {
	return "model_1_with_many_2_manies"
}

// IsPrimaryKeyZero implements Model interface method.
func (m *Model1WithMany2Many) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (m *Model1WithMany2Many) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (m *Model1WithMany2Many) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Model1WithMany2Many'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *Model1WithMany2Many) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if Model1WithMany2Many implements Fielder interface.
var _ Fielder = &Model1WithMany2Many{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *Model1WithMany2Many) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Model1WithMany2Many'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (m *Model1WithMany2Many) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *Model1WithMany2Many) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *Model1WithMany2Many) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *Model1WithMany2Many) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Model1WithMany2Many'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *Model1WithMany2Many) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Model1WithMany2Many'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *Model1WithMany2Many) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Model1WithMany2Many'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *Model1WithMany2Many) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Model1WithMany2Many'", field.Name())
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Model1WithMany2Many{}

// AddRelationModel implements MultiRelationer interface.
func (m *Model1WithMany2Many) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Synced
		model2WithMany2Many, ok := model.(*Model2WithMany2Many)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Synced'", model)
		}
		m.Synced = append(m.Synced, model2WithMany2Many)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'Model1WithMany2Many'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (m *Model1WithMany2Many) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		for _, model := range m.Synced {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (m *Model1WithMany2Many) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		if index > len(m.Synced)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'Model1WithMany2Many', Field Synced")
		}
		return m.Synced[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (m *Model1WithMany2Many) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Synced
		return len(m.Synced), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (m *Model1WithMany2Many) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 1: // Synced
		temp := make([]*Model2WithMany2Many, len(models))
		for i, model := range models {
			model2WithMany2Many, ok := model.(*Model2WithMany2Many)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Synced'", model)
			}
			temp[i] = model2WithMany2Many
		}
		m.Synced = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'Model1WithMany2Many'", relation.String())
	}
	return nil
}

// Compile time check if Model2WithMany2Many implements Model interface.
var _ Model = &Model2WithMany2Many{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Model2WithMany2Many'.
func (m *Model2WithMany2Many) NeuronCollectionName() string {
	return "model_2_with_many_2_manies"
}

// IsPrimaryKeyZero implements Model interface method.
func (m *Model2WithMany2Many) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (m *Model2WithMany2Many) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (m *Model2WithMany2Many) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Model2WithMany2Many'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *Model2WithMany2Many) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if Model2WithMany2Many implements Fielder interface.
var _ Fielder = &Model2WithMany2Many{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *Model2WithMany2Many) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Model2WithMany2Many'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (m *Model2WithMany2Many) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *Model2WithMany2Many) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *Model2WithMany2Many) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *Model2WithMany2Many) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Model2WithMany2Many'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *Model2WithMany2Many) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Model2WithMany2Many'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *Model2WithMany2Many) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Model2WithMany2Many'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *Model2WithMany2Many) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Model2WithMany2Many'", field.Name())
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Model2WithMany2Many{}

// AddRelationModel implements MultiRelationer interface.
func (m *Model2WithMany2Many) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Synced
		model1WithMany2Many, ok := model.(*Model1WithMany2Many)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Synced'", model)
		}
		m.Synced = append(m.Synced, model1WithMany2Many)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'Model2WithMany2Many'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (m *Model2WithMany2Many) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		for _, model := range m.Synced {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (m *Model2WithMany2Many) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Synced
		if index > len(m.Synced)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'Model2WithMany2Many', Field Synced")
		}
		return m.Synced[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (m *Model2WithMany2Many) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Synced
		return len(m.Synced), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (m *Model2WithMany2Many) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 1: // Synced
		temp := make([]*Model1WithMany2Many, len(models))
		for i, model := range models {
			model1WithMany2Many, ok := model.(*Model1WithMany2Many)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Synced'", model)
			}
			temp[i] = model1WithMany2Many
		}
		m.Synced = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'Model2WithMany2Many'", relation.String())
	}
	return nil
}

// Compile time check if ModelWithBelongsTo implements Model interface.
var _ Model = &ModelWithBelongsTo{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithBelongsTo'.
func (m *ModelWithBelongsTo) NeuronCollectionName() string {
	return "model_with_belongs_tos"
}

// IsPrimaryKeyZero implements Model interface method.
func (m *ModelWithBelongsTo) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (m *ModelWithBelongsTo) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (m *ModelWithBelongsTo) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithBelongsTo'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithBelongsTo) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if ModelWithBelongsTo implements Fielder interface.
var _ Fielder = &ModelWithBelongsTo{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ModelWithBelongsTo) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	case 1: // ForeignKey
		return &m.ForeignKey, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithBelongsTo'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithBelongsTo) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // ForeignKey
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithBelongsTo) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	case 1: // ForeignKey
		return m.ForeignKey == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithBelongsTo) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	case 1: // ForeignKey
		m.ForeignKey = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithBelongsTo) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithBelongsTo'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithBelongsTo) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithBelongsTo'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithBelongsTo) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // ForeignKey
		if v, ok := value.(int); ok {
			m.ForeignKey = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ForeignKey = int(v)
		case int16:
			m.ForeignKey = int(v)
		case int32:
			m.ForeignKey = int(v)
		case int64:
			m.ForeignKey = int(v)
		case uint:
			m.ForeignKey = int(v)
		case uint8:
			m.ForeignKey = int(v)
		case uint16:
			m.ForeignKey = int(v)
		case uint32:
			m.ForeignKey = int(v)
		case uint64:
			m.ForeignKey = int(v)
		case float32:
			m.ForeignKey = int(v)
		case float64:
			m.ForeignKey = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithBelongsTo'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithBelongsTo) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // ForeignKey
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithBelongsTo'", field.Name())
}

// Compile time check if ModelWithBelongsTo implements SingleRelationer interface.
var _ SingleRelationer = &ModelWithBelongsTo{}

// GetRelationModel implements SingleRelationer interface.
func (m *ModelWithBelongsTo) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 2: // BelongsTo
		if m.BelongsTo == nil {
			return nil, nil
		}
		return m.BelongsTo, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (m *ModelWithBelongsTo) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 2: // BelongsTo
		if model == nil {
			m.BelongsTo = nil
			return nil
		} else if belongsTo, ok := model.(*ModelWithHasOne); ok {
			m.BelongsTo = belongsTo
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation BelongsTo", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if ModelWithForeignKey implements Model interface.
var _ Model = &ModelWithForeignKey{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithForeignKey'.
func (m *ModelWithForeignKey) NeuronCollectionName() string {
	return "model_with_foreign_keys"
}

// IsPrimaryKeyZero implements Model interface method.
func (m *ModelWithForeignKey) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (m *ModelWithForeignKey) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (m *ModelWithForeignKey) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithForeignKey'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithForeignKey) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if ModelWithForeignKey implements Fielder interface.
var _ Fielder = &ModelWithForeignKey{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ModelWithForeignKey) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	case 1: // ForeignKey
		return &m.ForeignKey, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithForeignKey'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithForeignKey) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // ForeignKey
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithForeignKey) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	case 1: // ForeignKey
		return m.ForeignKey == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithForeignKey) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	case 1: // ForeignKey
		m.ForeignKey = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithForeignKey) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithForeignKey'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithForeignKey) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // ForeignKey
		return m.ForeignKey, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithForeignKey'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithForeignKey) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // ForeignKey
		if v, ok := value.(int); ok {
			m.ForeignKey = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ForeignKey = int(v)
		case int16:
			m.ForeignKey = int(v)
		case int32:
			m.ForeignKey = int(v)
		case int64:
			m.ForeignKey = int(v)
		case uint:
			m.ForeignKey = int(v)
		case uint8:
			m.ForeignKey = int(v)
		case uint16:
			m.ForeignKey = int(v)
		case uint32:
			m.ForeignKey = int(v)
		case uint64:
			m.ForeignKey = int(v)
		case float32:
			m.ForeignKey = int(v)
		case float64:
			m.ForeignKey = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithForeignKey'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithForeignKey) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // ForeignKey
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithForeignKey'", field.Name())
}

// Compile time check if ModelWithHasMany implements Model interface.
var _ Model = &ModelWithHasMany{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithHasMany'.
func (m *ModelWithHasMany) NeuronCollectionName() string {
	return "model_with_has_manies"
}

// IsPrimaryKeyZero implements Model interface method.
func (m *ModelWithHasMany) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (m *ModelWithHasMany) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (m *ModelWithHasMany) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithHasMany'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithHasMany) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if ModelWithHasMany implements Fielder interface.
var _ Fielder = &ModelWithHasMany{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ModelWithHasMany) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithHasMany'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithHasMany) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithHasMany) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithHasMany) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithHasMany) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithHasMany'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithHasMany) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithHasMany'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithHasMany) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithHasMany'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithHasMany) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithHasMany'", field.Name())
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &ModelWithHasMany{}

// AddRelationModel implements MultiRelationer interface.
func (m *ModelWithHasMany) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // HasMany
		modelWithForeignKey, ok := model.(*ModelWithForeignKey)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'HasMany'", model)
		}
		m.HasMany = append(m.HasMany, modelWithForeignKey)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'ModelWithHasMany'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (m *ModelWithHasMany) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // HasMany
		for _, model := range m.HasMany {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (m *ModelWithHasMany) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // HasMany
		if index > len(m.HasMany)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'ModelWithHasMany', Field HasMany")
		}
		return m.HasMany[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (m *ModelWithHasMany) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // HasMany
		return len(m.HasMany), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (m *ModelWithHasMany) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 1: // HasMany
		temp := make([]*ModelWithForeignKey, len(models))
		for i, model := range models {
			modelWithForeignKey, ok := model.(*ModelWithForeignKey)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'HasMany'", model)
			}
			temp[i] = modelWithForeignKey
		}
		m.HasMany = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'ModelWithHasMany'", relation.String())
	}
	return nil
}

// Compile time check if ModelWithHasOne implements Model interface.
var _ Model = &ModelWithHasOne{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithHasOne'.
func (m *ModelWithHasOne) NeuronCollectionName() string {
	return "model_with_has_ones"
}

// IsPrimaryKeyZero implements Model interface method.
func (m *ModelWithHasOne) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (m *ModelWithHasOne) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (m *ModelWithHasOne) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithHasOne'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithHasOne) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if ModelWithHasOne implements Fielder interface.
var _ Fielder = &ModelWithHasOne{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ModelWithHasOne) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithHasOne'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithHasOne) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithHasOne) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithHasOne) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithHasOne) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithHasOne'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithHasOne) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithHasOne'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithHasOne) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithHasOne'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithHasOne) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithHasOne'", field.Name())
}

// Compile time check if ModelWithHasOne implements SingleRelationer interface.
var _ SingleRelationer = &ModelWithHasOne{}

// GetRelationModel implements SingleRelationer interface.
func (m *ModelWithHasOne) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 1: // HasOne
		if m.HasOne == nil {
			return nil, nil
		}
		return m.HasOne, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (m *ModelWithHasOne) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // HasOne
		if model == nil {
			m.HasOne = nil
			return nil
		} else if hasOne, ok := model.(*ModelWithBelongsTo); ok {
			m.HasOne = hasOne
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation HasOne", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, m)
	}
}

// Compile time check if ModelWithNested implements Model interface.
var _ Model = &ModelWithNested{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'ModelWithNested'.
func (m *ModelWithNested) NeuronCollectionName() string {
	return "model_with_nesteds"
}

// IsPrimaryKeyZero implements Model interface method.
func (m *ModelWithNested) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (m *ModelWithNested) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithNested) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (m *ModelWithNested) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (m *ModelWithNested) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (m *ModelWithNested) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (m *ModelWithNested) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelWithNested'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithNested) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if ModelWithNested implements Fielder interface.
var _ Fielder = &ModelWithNested{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ModelWithNested) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	case 1: // PtrComposed
		return &m.PtrComposed, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithNested'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (m *ModelWithNested) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // PtrComposed
		return nil, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (m *ModelWithNested) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	case 1: // PtrComposed
		return m.PtrComposed == nil, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (m *ModelWithNested) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	case 1: // PtrComposed
		m.PtrComposed = nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (m *ModelWithNested) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // PtrComposed
		if m.PtrComposed == nil {
			return nil, nil
		}
		return *m.PtrComposed, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'ModelWithNested'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (m *ModelWithNested) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // PtrComposed
		return m.PtrComposed, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithNested'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (m *ModelWithNested) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // PtrComposed
		if value == nil {
			m.PtrComposed = nil
			return nil
		}
		if v, ok := value.(*NestedAttribute); ok {
			m.PtrComposed = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(NestedAttribute); ok {
			m.PtrComposed = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'ModelWithNested'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (m *ModelWithNested) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // PtrComposed
		return "", errors.Wrap(ErrFieldNotParser, "field 'PtrComposed' doesn't have string setter.")
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: ModelWithNested'", field.Name())
}

// Compile time check if NotTaggedModel implements Model interface.
var _ Model = &NotTaggedModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'NotTaggedModel'.
func (n *NotTaggedModel) NeuronCollectionName() string {
	return "not_tagged_models"
}

// IsPrimaryKeyZero implements Model interface method.
func (n *NotTaggedModel) IsPrimaryKeyZero() bool {
	return n.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyValue() interface{} {
	return n.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(n.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyAddress() interface{} {
	return &n.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyHashableValue() interface{} {
	return n.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (n *NotTaggedModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (n *NotTaggedModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		n.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		n.ID = int(valueType)
	case int16:
		n.ID = int(valueType)
	case int32:
		n.ID = int(valueType)
	case int64:
		n.ID = int(valueType)
	case uint:
		n.ID = int(valueType)
	case uint8:
		n.ID = int(valueType)
	case uint16:
		n.ID = int(valueType)
	case uint32:
		n.ID = int(valueType)
	case uint64:
		n.ID = int(valueType)
	case float32:
		n.ID = int(valueType)
	case float64:
		n.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'NotTaggedModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (n *NotTaggedModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	n.ID = int(tmp)
	return nil
}

// Compile time check if NotTaggedModel implements Fielder interface.
var _ Fielder = &NotTaggedModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (n *NotTaggedModel) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &n.ID, nil
	case 1: // Name
		return &n.Name, nil
	case 2: // Age
		return &n.Age, nil
	case 3: // Created
		return &n.Created, nil
	case 4: // OtherNotTaggedModelID
		return &n.OtherNotTaggedModelID, nil
	case 6: // ManyRelationID
		return &n.ManyRelationID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: NotTaggedModel'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (n *NotTaggedModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Name
		return "", nil
	case 2: // Age
		return 0, nil
	case 3: // Created
		return time.Time{}, nil
	case 4: // OtherNotTaggedModelID
		return 0, nil
	case 6: // ManyRelationID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (n *NotTaggedModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return n.ID == 0, nil
	case 1: // Name
		return n.Name == "", nil
	case 2: // Age
		return n.Age == 0, nil
	case 3: // Created
		return n.Created == time.Time{}, nil
	case 4: // OtherNotTaggedModelID
		return n.OtherNotTaggedModelID == 0, nil
	case 6: // ManyRelationID
		return n.ManyRelationID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (n *NotTaggedModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		n.ID = 0
	case 1: // Name
		n.Name = ""
	case 2: // Age
		n.Age = 0
	case 3: // Created
		n.Created = time.Time{}
	case 4: // OtherNotTaggedModelID
		n.OtherNotTaggedModelID = 0
	case 6: // ManyRelationID
		n.ManyRelationID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (n *NotTaggedModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return n.ID, nil
	case 1: // Name
		return n.Name, nil
	case 2: // Age
		return n.Age, nil
	case 3: // Created
		return n.Created, nil
	case 4: // OtherNotTaggedModelID
		return n.OtherNotTaggedModelID, nil
	case 6: // ManyRelationID
		return n.ManyRelationID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'NotTaggedModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (n *NotTaggedModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return n.ID, nil
	case 1: // Name
		return n.Name, nil
	case 2: // Age
		return n.Age, nil
	case 3: // Created
		return n.Created, nil
	case 4: // OtherNotTaggedModelID
		return n.OtherNotTaggedModelID, nil
	case 6: // ManyRelationID
		return n.ManyRelationID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: NotTaggedModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (n *NotTaggedModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			n.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			n.ID = int(v)
		case int16:
			n.ID = int(v)
		case int32:
			n.ID = int(v)
		case int64:
			n.ID = int(v)
		case uint:
			n.ID = int(v)
		case uint8:
			n.ID = int(v)
		case uint16:
			n.ID = int(v)
		case uint32:
			n.ID = int(v)
		case uint64:
			n.ID = int(v)
		case float32:
			n.ID = int(v)
		case float64:
			n.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Name
		if v, ok := value.(string); ok {
			n.Name = v
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			n.Name = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // Age
		if v, ok := value.(int); ok {
			n.Age = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			n.Age = int(v)
		case int16:
			n.Age = int(v)
		case int32:
			n.Age = int(v)
		case int64:
			n.Age = int(v)
		case uint:
			n.Age = int(v)
		case uint8:
			n.Age = int(v)
		case uint16:
			n.Age = int(v)
		case uint32:
			n.Age = int(v)
		case uint64:
			n.Age = int(v)
		case float32:
			n.Age = int(v)
		case float64:
			n.Age = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 3: // Created
		if v, ok := value.(time.Time); ok {
			n.Created = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // OtherNotTaggedModelID
		if v, ok := value.(int); ok {
			n.OtherNotTaggedModelID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			n.OtherNotTaggedModelID = int(v)
		case int16:
			n.OtherNotTaggedModelID = int(v)
		case int32:
			n.OtherNotTaggedModelID = int(v)
		case int64:
			n.OtherNotTaggedModelID = int(v)
		case uint:
			n.OtherNotTaggedModelID = int(v)
		case uint8:
			n.OtherNotTaggedModelID = int(v)
		case uint16:
			n.OtherNotTaggedModelID = int(v)
		case uint32:
			n.OtherNotTaggedModelID = int(v)
		case uint64:
			n.OtherNotTaggedModelID = int(v)
		case float32:
			n.OtherNotTaggedModelID = int(v)
		case float64:
			n.OtherNotTaggedModelID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 6: // ManyRelationID
		if v, ok := value.(int); ok {
			n.ManyRelationID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			n.ManyRelationID = int(v)
		case int16:
			n.ManyRelationID = int(v)
		case int32:
			n.ManyRelationID = int(v)
		case int64:
			n.ManyRelationID = int(v)
		case uint:
			n.ManyRelationID = int(v)
		case uint8:
			n.ManyRelationID = int(v)
		case uint16:
			n.ManyRelationID = int(v)
		case uint32:
			n.ManyRelationID = int(v)
		case uint64:
			n.ManyRelationID = int(v)
		case float32:
			n.ManyRelationID = int(v)
		case float64:
			n.ManyRelationID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'NotTaggedModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (n *NotTaggedModel) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // Name
		return value, nil
	case 2: // Age
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 3: // Created
		temp := n.Created
		if err := n.Created.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'Created' value: '%v' to parse string. Err: %v", n.Created, err)
		}
		bt, err := n.Created.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'Created' value: '%v' to parse string. Err: %v", n.Created, err)
		}
		n.Created = temp
		return string(bt), nil
	case 4: // OtherNotTaggedModelID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 6: // ManyRelationID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: NotTaggedModel'", field.Name())
}

// Compile time check if NotTaggedModel implements SingleRelationer interface.
var _ SingleRelationer = &NotTaggedModel{}

// GetRelationModel implements SingleRelationer interface.
func (n *NotTaggedModel) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 5: // Related
		if n.Related == nil {
			return nil, nil
		}
		return n.Related, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, n)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (n *NotTaggedModel) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 5: // Related
		if model == nil {
			n.Related = nil
			return nil
		} else if related, ok := model.(*OtherNotTaggedModel); ok {
			n.Related = related
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Related", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, n)
	}
}

// Compile time check if OrderModel implements Model interface.
var _ Model = &OrderModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'OrderModel'.
func (o *OrderModel) NeuronCollectionName() string {
	return "order_models"
}

// IsPrimaryKeyZero implements Model interface method.
func (o *OrderModel) IsPrimaryKeyZero() bool {
	return o.ID == uuid.UUID([16]byte{})
}

// GetPrimaryKeyValue implements Model interface method.
func (o *OrderModel) GetPrimaryKeyValue() interface{} {
	return o.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (o *OrderModel) GetPrimaryKeyStringValue() (string, error) {
	id, err := o.ID.MarshalText()
	if err != nil {
		return "", errors.Wrapf(ErrFieldValue, "invalid primary field value: %v to parse string. Err: %v", o.ID, err)
	}
	return string(id), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (o *OrderModel) GetPrimaryKeyAddress() interface{} {
	return &o.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (o *OrderModel) GetPrimaryKeyHashableValue() interface{} {
	return o.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (o *OrderModel) GetPrimaryKeyZeroValue() interface{} {
	return uuid.UUID([16]byte{})
}

// SetPrimaryKey implements Model interface method.
func (o *OrderModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uuid.UUID); ok {
		o.ID = v
		return nil
	} else if v, ok := value.([16]byte); ok {
		o.ID = uuid.UUID(v)
	}
	return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, o)
}

// SetPrimaryKeyStringValue implements Model interface method.
func (o *OrderModel) SetPrimaryKeyStringValue(value string) error {
	if err := o.ID.UnmarshalText([]byte(value)); err != nil {
		return errors.Wrapf(ErrFieldValue, "invalid primary field value: %v to parse string. Err: %v", o.ID, err)
	}
	return nil
}

// Compile time check if OrderModel implements Fielder interface.
var _ Fielder = &OrderModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (o *OrderModel) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &o.ID, nil
	case 1: // Name
		return &o.Name, nil
	case 2: // First
		return &o.First, nil
	case 3: // Second
		return &o.Second, nil
	case 4: // Third
		return &o.Third, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: OrderModel'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (o *OrderModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return uuid.UUID([16]byte{}), nil
	case 1: // Name
		return "", nil
	case 2: // First
		return "", nil
	case 3: // Second
		return 0, nil
	case 4: // Third
		return "", nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (o *OrderModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID == uuid.UUID([16]byte{}), nil
	case 1: // Name
		return o.Name == "", nil
	case 2: // First
		return o.First == "", nil
	case 3: // Second
		return o.Second == 0, nil
	case 4: // Third
		return o.Third == "", nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (o *OrderModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		o.ID = uuid.UUID([16]byte{})
	case 1: // Name
		o.Name = ""
	case 2: // First
		o.First = ""
	case 3: // Second
		o.Second = 0
	case 4: // Third
		o.Third = ""
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (o *OrderModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID, nil
	case 1: // Name
		return o.Name, nil
	case 2: // First
		return o.First, nil
	case 3: // Second
		return o.Second, nil
	case 4: // Third
		return o.Third, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'OrderModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (o *OrderModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID, nil
	case 1: // Name
		return o.Name, nil
	case 2: // First
		return o.First, nil
	case 3: // Second
		return o.Second, nil
	case 4: // Third
		return o.Third, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: OrderModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (o *OrderModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uuid.UUID); ok {
			o.ID = v
			return nil
		}
		if generic, ok := value.([]interface{}); ok {
			if len(generic) > 16 {
				return errors.Wrapf(ErrFieldValue, "provided too many values for the field: 'ID")
			}
			for i, item := range generic {
				if v, ok := item.(byte); ok {
					o.ID[i] = v
					continue
				}

			}
			return nil
		}
		// Checked wrapped types.
		if v, ok := value.([16]byte); ok {
			o.ID = uuid.UUID(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 1: // Name
		if v, ok := value.(string); ok {
			o.Name = v
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			o.Name = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // First
		if v, ok := value.(string); ok {
			o.First = v
			return nil
		}

		// Check alternate types for the First.
		if v, ok := value.([]byte); ok {
			o.First = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Second
		if v, ok := value.(int); ok {
			o.Second = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			o.Second = int(v)
		case int16:
			o.Second = int(v)
		case int32:
			o.Second = int(v)
		case int64:
			o.Second = int(v)
		case uint:
			o.Second = int(v)
		case uint8:
			o.Second = int(v)
		case uint16:
			o.Second = int(v)
		case uint32:
			o.Second = int(v)
		case uint64:
			o.Second = int(v)
		case float32:
			o.Second = int(v)
		case float64:
			o.Second = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // Third
		if v, ok := value.(string); ok {
			o.Third = v
			return nil
		}

		// Check alternate types for the Third.
		if v, ok := value.([]byte); ok {
			o.Third = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'OrderModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (o *OrderModel) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		temp := o.ID
		if err := o.ID.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'ID' value: '%v' to parse string. Err: %v", o.ID, err)
		}
		bt, err := o.ID.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'ID' value: '%v' to parse string. Err: %v", o.ID, err)
		}
		o.ID = temp
		return string(bt), nil
	case 1: // Name
		return value, nil
	case 2: // First
		return value, nil
	case 3: // Second
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 4: // Third
		return value, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: OrderModel'", field.Name())
}

// Compile time check if OtherNotTaggedModel implements Model interface.
var _ Model = &OtherNotTaggedModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'OtherNotTaggedModel'.
func (o *OtherNotTaggedModel) NeuronCollectionName() string {
	return "other_not_tagged_models"
}

// IsPrimaryKeyZero implements Model interface method.
func (o *OtherNotTaggedModel) IsPrimaryKeyZero() bool {
	return o.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyValue() interface{} {
	return o.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(o.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyAddress() interface{} {
	return &o.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyHashableValue() interface{} {
	return o.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (o *OtherNotTaggedModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (o *OtherNotTaggedModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		o.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		o.ID = int(valueType)
	case int16:
		o.ID = int(valueType)
	case int32:
		o.ID = int(valueType)
	case int64:
		o.ID = int(valueType)
	case uint:
		o.ID = int(valueType)
	case uint8:
		o.ID = int(valueType)
	case uint16:
		o.ID = int(valueType)
	case uint32:
		o.ID = int(valueType)
	case uint64:
		o.ID = int(valueType)
	case float32:
		o.ID = int(valueType)
	case float64:
		o.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'OtherNotTaggedModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (o *OtherNotTaggedModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	o.ID = int(tmp)
	return nil
}

// Compile time check if OtherNotTaggedModel implements Fielder interface.
var _ Fielder = &OtherNotTaggedModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (o *OtherNotTaggedModel) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &o.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: OtherNotTaggedModel'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (o *OtherNotTaggedModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (o *OtherNotTaggedModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (o *OtherNotTaggedModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		o.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (o *OtherNotTaggedModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'OtherNotTaggedModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (o *OtherNotTaggedModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: OtherNotTaggedModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (o *OtherNotTaggedModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			o.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			o.ID = int(v)
		case int16:
			o.ID = int(v)
		case int32:
			o.ID = int(v)
		case int64:
			o.ID = int(v)
		case uint:
			o.ID = int(v)
		case uint8:
			o.ID = int(v)
		case uint16:
			o.ID = int(v)
		case uint32:
			o.ID = int(v)
		case uint64:
			o.ID = int(v)
		case float32:
			o.ID = int(v)
		case float64:
			o.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'OtherNotTaggedModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (o *OtherNotTaggedModel) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: OtherNotTaggedModel'", field.Name())
}

// Compile time check if OtherNotTaggedModel implements SingleRelationer interface.
var _ SingleRelationer = &OtherNotTaggedModel{}

// GetRelationModel implements SingleRelationer interface.
func (o *OtherNotTaggedModel) GetRelationModel(relation *StructField) (Model, error) {
	switch relation.Index[0] {
	case 1: // SingleRelated
		if o.SingleRelated == nil {
			return nil, nil
		}
		return o.SingleRelated, nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
}

// SetRelationModel implements SingleRelationer interface.
func (o *OtherNotTaggedModel) SetRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // SingleRelated
		if model == nil {
			o.SingleRelated = nil
			return nil
		} else if singleRelated, ok := model.(*NotTaggedModel); ok {
			o.SingleRelated = singleRelated
			return nil
		}
		return errors.Wrapf(ErrInvalidRelationValue, "provided invalid model value: '%T' for relation SingleRelated", model)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &OtherNotTaggedModel{}

// AddRelationModel implements MultiRelationer interface.
func (o *OtherNotTaggedModel) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 2: // ManyRelation
		notTaggedModel, ok := model.(*NotTaggedModel)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'ManyRelation'", model)
		}
		o.ManyRelation = append(o.ManyRelation, notTaggedModel)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'OtherNotTaggedModel'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (o *OtherNotTaggedModel) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 2: // ManyRelation
		for _, model := range o.ManyRelation {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (o *OtherNotTaggedModel) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 2: // ManyRelation
		if index > len(o.ManyRelation)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'OtherNotTaggedModel', Field ManyRelation")
		}
		return o.ManyRelation[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (o *OtherNotTaggedModel) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 2: // ManyRelation
		return len(o.ManyRelation), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, o)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (o *OtherNotTaggedModel) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 2: // ManyRelation
		temp := make([]*NotTaggedModel, len(models))
		for i, model := range models {
			notTaggedModel, ok := model.(*NotTaggedModel)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'ManyRelation'", model)
			}
			temp[i] = notTaggedModel
		}
		o.ManyRelation = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'OtherNotTaggedModel'", relation.String())
	}
	return nil
}

// Compile time check if Second implements Model interface.
var _ Model = &Second{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Second'.
func (s *Second) NeuronCollectionName() string {
	return "seconds"
}

// IsPrimaryKeyZero implements Model interface method.
func (s *Second) IsPrimaryKeyZero() bool {
	return s.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (s *Second) GetPrimaryKeyValue() interface{} {
	return s.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (s *Second) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(s.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (s *Second) GetPrimaryKeyAddress() interface{} {
	return &s.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (s *Second) GetPrimaryKeyHashableValue() interface{} {
	return s.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (s *Second) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (s *Second) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		s.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		s.ID = int(valueType)
	case int16:
		s.ID = int(valueType)
	case int32:
		s.ID = int(valueType)
	case int64:
		s.ID = int(valueType)
	case uint:
		s.ID = int(valueType)
	case uint8:
		s.ID = int(valueType)
	case uint16:
		s.ID = int(valueType)
	case uint32:
		s.ID = int(valueType)
	case uint64:
		s.ID = int(valueType)
	case float32:
		s.ID = int(valueType)
	case float64:
		s.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Second'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (s *Second) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	s.ID = int(tmp)
	return nil
}

// Compile time check if Second implements Fielder interface.
var _ Fielder = &Second{}

// GetFieldsAddress gets the address of provided 'field'.
func (s *Second) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &s.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Second'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (s *Second) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (s *Second) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return s.ID == 0, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (s *Second) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		s.ID = 0
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (s *Second) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return s.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Second'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (s *Second) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return s.ID, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Second'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (s *Second) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			s.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			s.ID = int(v)
		case int16:
			s.ID = int(v)
		case int32:
			s.ID = int(v)
		case int64:
			s.ID = int(v)
		case uint:
			s.ID = int(v)
		case uint8:
			s.ID = int(v)
		case uint16:
			s.ID = int(v)
		case uint32:
			s.ID = int(v)
		case uint64:
			s.ID = int(v)
		case float32:
			s.ID = int(v)
		case float64:
			s.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Second'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (s *Second) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Second'", field.Name())
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &Second{}

// AddRelationModel implements MultiRelationer interface.
func (s *Second) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Firsts
		first, ok := model.(*First)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Firsts'", model)
		}
		s.Firsts = append(s.Firsts, first)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'Second'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (s *Second) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Firsts
		for _, model := range s.Firsts {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, s)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (s *Second) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Firsts
		if index > len(s.Firsts)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'Second', Field Firsts")
		}
		return s.Firsts[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, s)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (s *Second) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Firsts
		return len(s.Firsts), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, s)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (s *Second) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 1: // Firsts
		temp := make([]*First, len(models))
		for i, model := range models {
			first, ok := model.(*First)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Firsts'", model)
			}
			temp[i] = first
		}
		s.Firsts = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'Second'", relation.String())
	}
	return nil
}

// Compile time check if TModel implements Model interface.
var _ Model = &TModel{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'TModel'.
func (t *TModel) NeuronCollectionName() string {
	return "t_models"
}

// IsPrimaryKeyZero implements Model interface method.
func (t *TModel) IsPrimaryKeyZero() bool {
	return t.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (t *TModel) GetPrimaryKeyValue() interface{} {
	return t.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (t *TModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(t.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (t *TModel) GetPrimaryKeyAddress() interface{} {
	return &t.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (t *TModel) GetPrimaryKeyHashableValue() interface{} {
	return t.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (t *TModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (t *TModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		t.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		t.ID = int(valueType)
	case int16:
		t.ID = int(valueType)
	case int32:
		t.ID = int(valueType)
	case int64:
		t.ID = int(valueType)
	case uint:
		t.ID = int(valueType)
	case uint8:
		t.ID = int(valueType)
	case uint16:
		t.ID = int(valueType)
	case uint32:
		t.ID = int(valueType)
	case uint64:
		t.ID = int(valueType)
	case float32:
		t.ID = int(valueType)
	case float64:
		t.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'TModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (t *TModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	t.ID = int(tmp)
	return nil
}

// Compile time check if TModel implements Fielder interface.
var _ Fielder = &TModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (t *TModel) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &t.ID, nil
	case 1: // CreatedTime
		return &t.CreatedTime, nil
	case 2: // UpdatedTime
		return &t.UpdatedTime, nil
	case 3: // DeletedTime
		return &t.DeletedTime, nil
	case 4: // Number
		return &t.Number, nil
	case 5: // String
		return &t.String, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: TModel'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (t *TModel) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // CreatedTime
		return time.Time{}, nil
	case 2: // UpdatedTime
		return nil, nil
	case 3: // DeletedTime
		return nil, nil
	case 4: // Number
		return 0, nil
	case 5: // String
		return "", nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (t *TModel) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID == 0, nil
	case 1: // CreatedTime
		return t.CreatedTime == time.Time{}, nil
	case 2: // UpdatedTime
		return t.UpdatedTime == nil, nil
	case 3: // DeletedTime
		return t.DeletedTime == nil, nil
	case 4: // Number
		return t.Number == 0, nil
	case 5: // String
		return t.String == "", nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (t *TModel) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		t.ID = 0
	case 1: // CreatedTime
		t.CreatedTime = time.Time{}
	case 2: // UpdatedTime
		t.UpdatedTime = nil
	case 3: // DeletedTime
		t.DeletedTime = nil
	case 4: // Number
		t.Number = 0
	case 5: // String
		t.String = ""
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (t *TModel) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID, nil
	case 1: // CreatedTime
		return t.CreatedTime, nil
	case 2: // UpdatedTime
		if t.UpdatedTime == nil {
			return nil, nil
		}
		return *t.UpdatedTime, nil
	case 3: // DeletedTime
		if t.DeletedTime == nil {
			return nil, nil
		}
		return *t.DeletedTime, nil
	case 4: // Number
		return t.Number, nil
	case 5: // String
		return t.String, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'TModel'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (t *TModel) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID, nil
	case 1: // CreatedTime
		return t.CreatedTime, nil
	case 2: // UpdatedTime
		return t.UpdatedTime, nil
	case 3: // DeletedTime
		return t.DeletedTime, nil
	case 4: // Number
		return t.Number, nil
	case 5: // String
		return t.String, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: TModel'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (t *TModel) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			t.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			t.ID = int(v)
		case int16:
			t.ID = int(v)
		case int32:
			t.ID = int(v)
		case int64:
			t.ID = int(v)
		case uint:
			t.ID = int(v)
		case uint8:
			t.ID = int(v)
		case uint16:
			t.ID = int(v)
		case uint32:
			t.ID = int(v)
		case uint64:
			t.ID = int(v)
		case float32:
			t.ID = int(v)
		case float64:
			t.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // CreatedTime
		if v, ok := value.(time.Time); ok {
			t.CreatedTime = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedTime
		if value == nil {
			t.UpdatedTime = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			t.UpdatedTime = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			t.UpdatedTime = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedTime
		if value == nil {
			t.DeletedTime = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			t.DeletedTime = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			t.DeletedTime = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // Number
		if v, ok := value.(int); ok {
			t.Number = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			t.Number = int(v)
		case int16:
			t.Number = int(v)
		case int32:
			t.Number = int(v)
		case int64:
			t.Number = int(v)
		case uint:
			t.Number = int(v)
		case uint8:
			t.Number = int(v)
		case uint16:
			t.Number = int(v)
		case uint32:
			t.Number = int(v)
		case uint64:
			t.Number = int(v)
		case float32:
			t.Number = int(v)
		case float64:
			t.Number = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 5: // String
		if v, ok := value.(string); ok {
			t.String = v
			return nil
		}

		// Check alternate types for the String.
		if v, ok := value.([]byte); ok {
			t.String = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'TModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (t *TModel) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // CreatedTime
		temp := t.CreatedTime
		if err := t.CreatedTime.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedTime' value: '%v' to parse string. Err: %v", t.CreatedTime, err)
		}
		bt, err := t.CreatedTime.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedTime' value: '%v' to parse string. Err: %v", t.CreatedTime, err)
		}
		t.CreatedTime = temp
		return string(bt), nil
	case 2: // UpdatedTime
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedTime' value: '%v' to parse string. Err: %v", t.UpdatedTime, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedTime' value: '%v' to parse string. Err: %v", t.UpdatedTime, err)
		}

		return string(bt), nil
	case 3: // DeletedTime
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedTime' value: '%v' to parse string. Err: %v", t.DeletedTime, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedTime' value: '%v' to parse string. Err: %v", t.DeletedTime, err)
		}

		return string(bt), nil
	case 4: // Number
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 5: // String
		return value, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: TModel'", field.Name())
}

// Compile time check if Timer implements Model interface.
var _ Model = &Timer{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'Timer'.
func (t *Timer) NeuronCollectionName() string {
	return "timers"
}

// IsPrimaryKeyZero implements Model interface method.
func (t *Timer) IsPrimaryKeyZero() bool {
	return t.ID == 0
}

// GetPrimaryKeyValue implements Model interface method.
func (t *Timer) GetPrimaryKeyValue() interface{} {
	return t.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (t *Timer) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(t.ID), 10), nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (t *Timer) GetPrimaryKeyAddress() interface{} {
	return &t.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (t *Timer) GetPrimaryKeyHashableValue() interface{} {
	return t.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (t *Timer) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements Model interface method.
func (t *Timer) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		t.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		t.ID = int(valueType)
	case int16:
		t.ID = int(valueType)
	case int32:
		t.ID = int(valueType)
	case int64:
		t.ID = int(valueType)
	case uint:
		t.ID = int(valueType)
	case uint8:
		t.ID = int(valueType)
	case uint16:
		t.ID = int(valueType)
	case uint32:
		t.ID = int(valueType)
	case uint64:
		t.ID = int(valueType)
	case float32:
		t.ID = int(valueType)
	case float64:
		t.ID = int(valueType)
	default:
		return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Timer'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements Model interface method.
func (t *Timer) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, IntegerBitSize)
	if err != nil {
		return err
	}
	t.ID = int(tmp)
	return nil
}

// Compile time check if Timer implements Fielder interface.
var _ Fielder = &Timer{}

// GetFieldsAddress gets the address of provided 'field'.
func (t *Timer) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &t.ID, nil
	case 1: // CreatedAt
		return &t.CreatedAt, nil
	case 2: // UpdatedAt
		return &t.UpdatedAt, nil
	case 3: // DeletedAt
		return &t.DeletedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Timer'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (t *Timer) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // UpdatedAt
		return nil, nil
	case 3: // DeletedAt
		return nil, nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (t *Timer) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID == 0, nil
	case 1: // CreatedAt
		return t.CreatedAt == time.Time{}, nil
	case 2: // UpdatedAt
		return t.UpdatedAt == nil, nil
	case 3: // DeletedAt
		return t.DeletedAt == nil, nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (t *Timer) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		t.ID = 0
	case 1: // CreatedAt
		t.CreatedAt = time.Time{}
	case 2: // UpdatedAt
		t.UpdatedAt = nil
	case 3: // DeletedAt
		t.DeletedAt = nil
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (t *Timer) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID, nil
	case 1: // CreatedAt
		return t.CreatedAt, nil
	case 2: // UpdatedAt
		if t.UpdatedAt == nil {
			return nil, nil
		}
		return *t.UpdatedAt, nil
	case 3: // DeletedAt
		if t.DeletedAt == nil {
			return nil, nil
		}
		return *t.DeletedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Timer'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (t *Timer) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return t.ID, nil
	case 1: // CreatedAt
		return t.CreatedAt, nil
	case 2: // UpdatedAt
		return t.UpdatedAt, nil
	case 3: // DeletedAt
		return t.DeletedAt, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Timer'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (t *Timer) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			t.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			t.ID = int(v)
		case int16:
			t.ID = int(v)
		case int32:
			t.ID = int(v)
		case int64:
			t.ID = int(v)
		case uint:
			t.ID = int(v)
		case uint8:
			t.ID = int(v)
		case uint16:
			t.ID = int(v)
		case uint32:
			t.ID = int(v)
		case uint64:
			t.ID = int(v)
		case float32:
			t.ID = int(v)
		case float64:
			t.ID = int(v)
		default:
			return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			t.CreatedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedAt
		if value == nil {
			t.UpdatedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			t.UpdatedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			t.UpdatedAt = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedAt
		if value == nil {
			t.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			t.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			t.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Timer'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (t *Timer) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, IntegerBitSize)
	case 1: // CreatedAt
		temp := t.CreatedAt
		if err := t.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", t.CreatedAt, err)
		}
		bt, err := t.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", t.CreatedAt, err)
		}
		t.CreatedAt = temp
		return string(bt), nil
	case 2: // UpdatedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", t.UpdatedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", t.UpdatedAt, err)
		}

		return string(bt), nil
	case 3: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", t.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", t.DeletedAt, err)
		}

		return string(bt), nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: Timer'", field.Name())
}

// Compile time check if User implements Model interface.
var _ Model = &User{}

// NeuronCollectionName implements Model interface method.
// Returns the name of the collection for the 'User'.
func (u *User) NeuronCollectionName() string {
	return "users"
}

// IsPrimaryKeyZero implements Model interface method.
func (u *User) IsPrimaryKeyZero() bool {
	return u.ID == ""
}

// GetPrimaryKeyValue implements Model interface method.
func (u *User) GetPrimaryKeyValue() interface{} {
	return u.ID
}

// GetPrimaryKeyStringValue implements Model interface method.
func (u *User) GetPrimaryKeyStringValue() (string, error) {
	return u.ID, nil
}

// GetPrimaryKeyAddress implements Model interface method.
func (u *User) GetPrimaryKeyAddress() interface{} {
	return &u.ID
}

// GetPrimaryKeyHashableValue implements Model interface method.
func (u *User) GetPrimaryKeyHashableValue() interface{} {
	return u.ID
}

// GetPrimaryKeyZeroValue implements Model interface method.
func (u *User) GetPrimaryKeyZeroValue() interface{} {
	return ""
}

// SetPrimaryKey implements Model interface method.
func (u *User) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(string); ok {
		u.ID = v
		return nil
	}
	// Check alternate types for given field.
	if v, ok := value.([]byte); ok {
		u.ID = string(v)
		return nil
	}
	return errors.Wrapf(ErrFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, u)
}

// SetPrimaryKeyStringValue implements Model interface method.
func (u *User) SetPrimaryKeyStringValue(value string) error {
	u.ID = value
	return nil
}

// Compile time check if User implements Fielder interface.
var _ Fielder = &User{}

// GetFieldsAddress gets the address of provided 'field'.
func (u *User) GetFieldsAddress(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &u.ID, nil
	case 2: // CreatedAt
		return &u.CreatedAt, nil
	case 3: // UpdatedAt
		return &u.UpdatedAt, nil
	case 4: // DeletedAt
		return &u.DeletedAt, nil
	case 5: // FirstName
		return &u.FirstName, nil
	case 6: // LastName
		return &u.LastName, nil
	case 7: // Email
		return &u.Email, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// GetFieldZeroValue implements Fielder interface.s
func (u *User) GetFieldZeroValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return "", nil
	case 2: // CreatedAt
		return time.Time{}, nil
	case 3: // UpdatedAt
		return time.Time{}, nil
	case 4: // DeletedAt
		return nil, nil
	case 5: // FirstName
		return "", nil
	case 6: // LastName
		return "", nil
	case 7: // Email
		return "", nil
	default:
		return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements Fielder interface.
func (u *User) IsFieldZero(field *StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID == "", nil
	case 2: // CreatedAt
		return u.CreatedAt == time.Time{}, nil
	case 3: // UpdatedAt
		return u.UpdatedAt == time.Time{}, nil
	case 4: // DeletedAt
		return u.DeletedAt == nil, nil
	case 5: // FirstName
		return u.FirstName == "", nil
	case 6: // LastName
		return u.LastName == "", nil
	case 7: // Email
		return u.Email == "", nil
	}
	return false, errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements Fielder interface.s
func (u *User) SetFieldZeroValue(field *StructField) error {
	switch field.Index[0] {
	case 0: // ID
		u.ID = ""
	case 2: // CreatedAt
		u.CreatedAt = time.Time{}
	case 3: // UpdatedAt
		u.UpdatedAt = time.Time{}
	case 4: // DeletedAt
		u.DeletedAt = nil
	case 5: // FirstName
		u.FirstName = ""
	case 6: // LastName
		u.LastName = ""
	case 7: // Email
		u.Email = ""
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements Fielder interface.
func (u *User) GetHashableFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 2: // CreatedAt
		return u.CreatedAt, nil
	case 3: // UpdatedAt
		return u.UpdatedAt, nil
	case 4: // DeletedAt
		if u.DeletedAt == nil {
			return nil, nil
		}
		return *u.DeletedAt, nil
	case 5: // FirstName
		return u.FirstName, nil
	case 6: // LastName
		return u.LastName, nil
	case 7: // Email
		return u.Email, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: 'User'", field.Name())
}

// GetFieldValue implements Fielder interface.
func (u *User) GetFieldValue(field *StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 2: // CreatedAt
		return u.CreatedAt, nil
	case 3: // UpdatedAt
		return u.UpdatedAt, nil
	case 4: // DeletedAt
		return u.DeletedAt, nil
	case 5: // FirstName
		return u.FirstName, nil
	case 6: // LastName
		return u.LastName, nil
	case 7: // Email
		return u.Email, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// SetFieldValue implements Fielder interface.
func (u *User) SetFieldValue(field *StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(string); ok {
			u.ID = v
			return nil
		}

		// Check alternate types for the ID.
		if v, ok := value.([]byte); ok {
			u.ID = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // CreatedAt
		if v, ok := value.(time.Time); ok {
			u.CreatedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // UpdatedAt
		if v, ok := value.(time.Time); ok {
			u.UpdatedAt = v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // DeletedAt
		if value == nil {
			u.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			u.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			u.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 5: // FirstName
		if v, ok := value.(string); ok {
			u.FirstName = v
			return nil
		}

		// Check alternate types for the FirstName.
		if v, ok := value.([]byte); ok {
			u.FirstName = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // LastName
		if v, ok := value.(string); ok {
			u.LastName = v
			return nil
		}

		// Check alternate types for the LastName.
		if v, ok := value.([]byte); ok {
			u.LastName = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 7: // Email
		if v, ok := value.(string); ok {
			u.Email = v
			return nil
		}

		// Check alternate types for the Email.
		if v, ok := value.([]byte); ok {
			u.Email = string(v)
			return nil
		}
		return errors.Wrapf(ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for the model: 'User'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements Model interface method.
func (u *User) ParseFieldsStringValue(field *StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return value, nil
	case 2: // CreatedAt
		temp := u.CreatedAt
		if err := u.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", u.CreatedAt, err)
		}
		bt, err := u.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", u.CreatedAt, err)
		}
		u.CreatedAt = temp
		return string(bt), nil
	case 3: // UpdatedAt
		temp := u.UpdatedAt
		if err := u.UpdatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", u.UpdatedAt, err)
		}
		bt, err := u.UpdatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", u.UpdatedAt, err)
		}
		u.UpdatedAt = temp
		return string(bt), nil
	case 4: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", u.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", u.DeletedAt, err)
		}

		return string(bt), nil
	case 5: // FirstName
		return value, nil
	case 6: // LastName
		return value, nil
	case 7: // Email
		return value, nil
	}
	return nil, errors.Wrapf(ErrInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// Compile time check for the MultiRelationer interface implementation.
var _ MultiRelationer = &User{}

// AddRelationModel implements MultiRelationer interface.
func (u *User) AddRelationModel(relation *StructField, model Model) error {
	switch relation.Index[0] {
	case 1: // Cars
		car, ok := model.(*Car)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Cars'", model)
		}
		u.Cars = append(u.Cars, car)
	case 8: // Jobs
		job, ok := model.(*Job)
		if !ok {
			return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Jobs'", model)
		}
		u.Jobs = append(u.Jobs, job)
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'User'", model)
	}
	return nil
}

// GetRelationModels implements MultiRelationer interface.
func (u *User) GetRelationModels(relation *StructField) (models []Model, err error) {
	switch relation.Index[0] {
	case 1: // Cars
		for _, model := range u.Cars {
			models = append(models, model)
		}
	case 8: // Jobs
		for _, model := range u.Jobs {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationModelAt implements MultiRelationer interface.
func (u *User) GetRelationModelAt(relation *StructField, index int) (models Model, err error) {
	switch relation.Index[0] {
	case 1: // Cars
		if index > len(u.Cars)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'User', Field Cars")
		}
		return u.Cars[index], nil
	case 8: // Jobs
		if index > len(u.Jobs)-1 {
			return nil, errors.Wrapf(ErrInvalidRelationIndex, "index out of possible range. Model: 'User', Field Jobs")
		}
		return u.Jobs[index], nil
	default:
		return nil, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationLen implements MultiRelationer interface.
func (u *User) GetRelationLen(relation *StructField) (int, error) {
	switch relation.Index[0] {
	case 1: // Cars
		return len(u.Cars), nil
	case 8: // Jobs
		return len(u.Jobs), nil
	default:
		return 0, errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// SetRelationModels implements MultiRelationer interface.
func (u *User) SetRelationModels(relation *StructField, models ...Model) error {
	switch relation.Index[0] {
	case 1: // Cars
		temp := make([]*Car, len(models))
		for i, model := range models {
			car, ok := model.(*Car)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Cars'", model)
			}
			temp[i] = car
		}
		u.Cars = temp
	case 8: // Jobs
		temp := make([]*Job, len(models))
		for i, model := range models {
			job, ok := model.(*Job)
			if !ok {
				return errors.Wrapf(ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Jobs'", model)
			}
			temp[i] = job
		}
		u.Jobs = temp
	default:
		return errors.Wrapf(ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'User'", relation.String())
	}
	return nil
}
